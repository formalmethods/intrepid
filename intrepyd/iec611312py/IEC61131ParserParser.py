# Generated from IEC61131Parser.g4 by ANTLR 4.9.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0118")
        buf.write("\u02d1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\3\2")
        buf.write("\3\2\3\2\5\2\u008a\n\2\3\2\5\2\u008d\n\2\3\2\3\2\3\2\3")
        buf.write("\2\5\2\u0093\n\2\3\2\5\2\u0096\n\2\3\2\5\2\u0099\n\2\3")
        buf.write("\2\5\2\u009c\n\2\3\3\3\3\3\4\6\4\u00a1\n\4\r\4\16\4\u00a2")
        buf.write("\3\4\5\4\u00a6\n\4\3\5\6\5\u00a9\n\5\r\5\16\5\u00aa\3")
        buf.write("\6\3\6\5\6\u00af\n\6\3\6\3\6\3\6\3\6\3\6\5\6\u00b6\n\6")
        buf.write("\3\6\3\6\3\6\3\6\3\6\5\6\u00bd\n\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\5\6\u00c4\n\6\3\6\3\6\3\6\3\6\3\6\5\6\u00cb\n\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\5\6\u00d2\n\6\3\6\3\6\3\6\5\6\u00d7\n\6")
        buf.write("\3\7\3\7\3\7\7\7\u00dc\n\7\f\7\16\7\u00df\13\7\3\b\5\b")
        buf.write("\u00e2\n\b\3\b\5\b\u00e5\n\b\3\b\3\b\3\b\3\b\3\b\3\b\5")
        buf.write("\b\u00ed\n\b\3\b\5\b\u00f0\n\b\3\b\3\b\3\b\5\b\u00f5\n")
        buf.write("\b\3\b\3\b\3\b\3\b\5\b\u00fb\n\b\3\t\3\t\3\t\3\n\3\n\3")
        buf.write("\13\3\13\5\13\u0104\n\13\3\13\3\13\3\13\3\13\3\13\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\13\3\13\5\13\u0112\n\13\3\f\3\f")
        buf.write("\3\f\3\f\3\f\3\f\3\f\3\f\5\f\u011c\n\f\3\r\3\r\3\16\3")
        buf.write("\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\3\16\3\16\3\16\5\16\u0132\n\16\3\16\3")
        buf.write("\16\3\16\5\16\u0137\n\16\3\17\3\17\3\20\3\20\3\20\5\20")
        buf.write("\u013e\n\20\3\21\3\21\3\22\3\22\3\22\5\22\u0145\n\22\3")
        buf.write("\22\3\22\3\22\5\22\u014a\n\22\3\23\6\23\u014d\n\23\r\23")
        buf.write("\16\23\u014e\3\24\3\24\3\25\3\25\3\25\3\25\3\25\5\25\u0158")
        buf.write("\n\25\3\25\3\25\3\25\7\25\u015d\n\25\f\25\16\25\u0160")
        buf.write("\13\25\3\26\3\26\3\27\3\27\3\27\7\27\u0167\n\27\f\27\16")
        buf.write("\27\u016a\13\27\3\30\5\30\u016d\n\30\3\30\3\30\5\30\u0171")
        buf.write("\n\30\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31")
        buf.write("\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\5\31\u0185\n")
        buf.write("\31\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\5\32\u0197\n\32\3\33\3")
        buf.write("\33\3\33\3\33\5\33\u019d\n\33\3\34\3\34\3\34\3\34\3\34")
        buf.write("\3\34\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\36\3\36\3\36")
        buf.write("\3\36\3\36\3\36\3\36\3\37\3\37\3\37\3\37\3\37\3\37\3\37")
        buf.write("\3\37\3 \6 \u01bc\n \r \16 \u01bd\3!\3!\3!\3!\3!\3\"\3")
        buf.write("\"\3\"\3#\6#\u01c9\n#\r#\16#\u01ca\3$\3$\3$\3$\3$\3$\5")
        buf.write("$\u01d3\n$\3$\3$\3%\6%\u01d8\n%\r%\16%\u01d9\3&\3&\3&")
        buf.write("\3&\3\'\3\'\3\'\7\'\u01e3\n\'\f\'\16\'\u01e6\13\'\3(\3")
        buf.write("(\3(\3(\3(\5(\u01ed\n(\3)\3)\3)\3)\3)\5)\u01f4\n)\3*\3")
        buf.write("*\3*\3*\3*\3*\7*\u01fc\n*\f*\16*\u01ff\13*\3*\3*\3+\3")
        buf.write("+\3,\3,\3,\3,\3,\5,\u020a\n,\3-\3-\3-\3-\3-\3-\3.\3.\7")
        buf.write(".\u0214\n.\f.\16.\u0217\13.\3.\3.\3.\3.\3/\3/\5/\u021f")
        buf.write("\n/\3\60\3\60\3\60\3\60\3\60\3\60\3\60\3\60\3\60\3\60")
        buf.write("\3\60\3\60\3\60\3\60\3\60\3\60\3\60\5\60\u0232\n\60\3")
        buf.write("\60\3\60\3\60\7\60\u0237\n\60\f\60\16\60\u023a\13\60\3")
        buf.write("\61\3\61\3\61\3\61\3\61\3\61\3\61\5\61\u0243\n\61\3\61")
        buf.write("\3\61\3\61\3\61\3\61\3\61\5\61\u024b\n\61\3\61\3\61\3")
        buf.write("\61\3\61\3\61\3\61\5\61\u0253\n\61\7\61\u0255\n\61\f\61")
        buf.write("\16\61\u0258\13\61\3\61\3\61\3\61\3\61\3\61\3\61\3\61")
        buf.write("\5\61\u0261\n\61\3\61\3\61\3\61\3\61\3\61\3\61\7\61\u0269")
        buf.write("\n\61\f\61\16\61\u026c\13\61\3\62\3\62\3\62\3\62\5\62")
        buf.write("\u0272\n\62\3\63\3\63\3\63\3\63\5\63\u0278\n\63\3\64\3")
        buf.write("\64\3\64\5\64\u027d\n\64\3\65\3\65\5\65\u0281\n\65\3\66")
        buf.write("\3\66\5\66\u0285\n\66\3\66\3\66\3\66\3\66\5\66\u028b\n")
        buf.write("\66\3\67\3\67\5\67\u028f\n\67\3\67\7\67\u0292\n\67\f\67")
        buf.write("\16\67\u0295\13\67\38\58\u0298\n8\38\38\39\39\39\59\u029f")
        buf.write("\n9\39\39\39\39\39\59\u02a6\n9\3:\3:\5:\u02aa\n:\3:\3")
        buf.write(":\3;\3;\3<\3<\3=\3=\3>\3>\3?\3?\3?\3?\3?\3@\3@\5@\u02bd")
        buf.write("\n@\3@\3@\6@\u02c1\n@\r@\16@\u02c2\3@\3@\5@\u02c7\n@\3")
        buf.write("A\3A\3A\3A\3B\3B\3C\3C\3C\2\5(^`D\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPR")
        buf.write("TVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082\u0084\2\26\6\2\u0081")
        buf.write("\u0082\u00de\u00de\u00e0\u00e1\u00f2\u00f2\4\2ii}}\4\2")
        buf.write("PP}}\n\2gg\u0091\u0091\u0093\u0094\u00a7\u00a7\u00ab\u00ac")
        buf.write("\u00af\u00af\u00b6\u00b8\u00ca\u00ca\3\2\177\u0080\6\2")
        buf.write("\u0081\u0082\u00c0\u00c0\u00de\u00e1\u00f2\u00f4\5\2\u0099")
        buf.write("\u0099\u00ad\u00ad\u00d1\u00d1\5\2\u009b\u009b\u00bd\u00bd")
        buf.write("\u00dd\u00dd\5\2\u009a\u009a\u00bc\u00bc\u00db\u00db\6")
        buf.write("\2\13\f\u00d3\u00d4\u0101\u0101\u0104\u0104\7\2\u00ba")
        buf.write("\u00bb\u00cc\u00cd\u00d5\u00da\u00e8\u00e9\u0106\u010c")
        buf.write("\3\2\17\24\4\2\u00d5\u00d6\u0106\u0106\4\2\25\26\u00d9")
        buf.write("\u00d9\3\2\27\30\4\2\u00b7\u00b8\u00ca\u00ca\4\2\u0090")
        buf.write("\u0090\u00ae\u00ae\4\2pp~~\3\2\37;\f\2vv\u0087\u0089\u009f")
        buf.write("\u00a2\u00c1\u00c8\u00cb\u00cd\u00d5\u00d6\u00d8\u00da")
        buf.write("\u00e2\u00f1\u0106\u010c\u010e\u010e\2\u0302\2\u009b\3")
        buf.write("\2\2\2\4\u009d\3\2\2\2\6\u00a5\3\2\2\2\b\u00a8\3\2\2\2")
        buf.write("\n\u00d6\3\2\2\2\f\u00dd\3\2\2\2\16\u00fa\3\2\2\2\20\u00fc")
        buf.write("\3\2\2\2\22\u00ff\3\2\2\2\24\u0111\3\2\2\2\26\u011b\3")
        buf.write("\2\2\2\30\u011d\3\2\2\2\32\u0136\3\2\2\2\34\u0138\3\2")
        buf.write("\2\2\36\u013d\3\2\2\2 \u013f\3\2\2\2\"\u0149\3\2\2\2$")
        buf.write("\u014c\3\2\2\2&\u0150\3\2\2\2(\u0157\3\2\2\2*\u0161\3")
        buf.write("\2\2\2,\u0163\3\2\2\2.\u016c\3\2\2\2\60\u0184\3\2\2\2")
        buf.write("\62\u0196\3\2\2\2\64\u019c\3\2\2\2\66\u019e\3\2\2\28\u01a4")
        buf.write("\3\2\2\2:\u01ab\3\2\2\2<\u01b2\3\2\2\2>\u01bb\3\2\2\2")
        buf.write("@\u01bf\3\2\2\2B\u01c4\3\2\2\2D\u01c8\3\2\2\2F\u01cc\3")
        buf.write("\2\2\2H\u01d7\3\2\2\2J\u01db\3\2\2\2L\u01df\3\2\2\2N\u01ec")
        buf.write("\3\2\2\2P\u01f3\3\2\2\2R\u01f5\3\2\2\2T\u0202\3\2\2\2")
        buf.write("V\u0204\3\2\2\2X\u020b\3\2\2\2Z\u0211\3\2\2\2\\\u021e")
        buf.write("\3\2\2\2^\u0231\3\2\2\2`\u0260\3\2\2\2b\u026d\3\2\2\2")
        buf.write("d\u0277\3\2\2\2f\u027c\3\2\2\2h\u0280\3\2\2\2j\u0284\3")
        buf.write("\2\2\2l\u028c\3\2\2\2n\u0297\3\2\2\2p\u029e\3\2\2\2r\u02a9")
        buf.write("\3\2\2\2t\u02ad\3\2\2\2v\u02af\3\2\2\2x\u02b1\3\2\2\2")
        buf.write("z\u02b3\3\2\2\2|\u02b5\3\2\2\2~\u02c0\3\2\2\2\u0080\u02c8")
        buf.write("\3\2\2\2\u0082\u02cc\3\2\2\2\u0084\u02ce\3\2\2\2\u0086")
        buf.write("\u0087\7q\2\2\u0087\u0089\7\u0110\2\2\u0088\u008a\5\b")
        buf.write("\5\2\u0089\u0088\3\2\2\2\u0089\u008a\3\2\2\2\u008a\u008c")
        buf.write("\3\2\2\2\u008b\u008d\5\6\4\2\u008c\u008b\3\2\2\2\u008c")
        buf.write("\u008d\3\2\2\2\u008d\u008e\3\2\2\2\u008e\u009c\7K\2\2")
        buf.write("\u008f\u0092\7@\2\2\u0090\u0093\7\u0110\2\2\u0091\u0093")
        buf.write("\5\4\3\2\u0092\u0090\3\2\2\2\u0092\u0091\3\2\2\2\u0093")
        buf.write("\u0095\3\2\2\2\u0094\u0096\5\b\5\2\u0095\u0094\3\2\2\2")
        buf.write("\u0095\u0096\3\2\2\2\u0096\u0098\3\2\2\2\u0097\u0099\5")
        buf.write("\6\4\2\u0098\u0097\3\2\2\2\u0098\u0099\3\2\2\2\u0099\u009a")
        buf.write("\3\2\2\2\u009a\u009c\7<\2\2\u009b\u0086\3\2\2\2\u009b")
        buf.write("\u008f\3\2\2\2\u009c\3\3\2\2\2\u009d\u009e\t\2\2\2\u009e")
        buf.write("\5\3\2\2\2\u009f\u00a1\5\26\f\2\u00a0\u009f\3\2\2\2\u00a1")
        buf.write("\u00a2\3\2\2\2\u00a2\u00a0\3\2\2\2\u00a2\u00a3\3\2\2\2")
        buf.write("\u00a3\u00a6\3\2\2\2\u00a4\u00a6\5D#\2\u00a5\u00a0\3\2")
        buf.write("\2\2\u00a5\u00a4\3\2\2\2\u00a6\7\3\2\2\2\u00a7\u00a9\5")
        buf.write("\n\6\2\u00a8\u00a7\3\2\2\2\u00a9\u00aa\3\2\2\2\u00aa\u00a8")
        buf.write("\3\2\2\2\u00aa\u00ab\3\2\2\2\u00ab\t\3\2\2\2\u00ac\u00ae")
        buf.write("\7O\2\2\u00ad\u00af\t\3\2\2\u00ae\u00ad\3\2\2\2\u00ae")
        buf.write("\u00af\3\2\2\2\u00af\u00b0\3\2\2\2\u00b0\u00b1\5\f\7\2")
        buf.write("\u00b1\u00b2\7r\2\2\u00b2\u00d7\3\2\2\2\u00b3\u00b5\7")
        buf.write("\u00d0\2\2\u00b4\u00b6\t\3\2\2\u00b5\u00b4\3\2\2\2\u00b5")
        buf.write("\u00b6\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7\u00b8\5\f\7\2")
        buf.write("\u00b8\u00b9\7r\2\2\u00b9\u00d7\3\2\2\2\u00ba\u00bc\7")
        buf.write("]\2\2\u00bb\u00bd\t\4\2\2\u00bc\u00bb\3\2\2\2\u00bc\u00bd")
        buf.write("\3\2\2\2\u00bd\u00be\3\2\2\2\u00be\u00bf\5\f\7\2\u00bf")
        buf.write("\u00c0\7r\2\2\u00c0\u00d7\3\2\2\2\u00c1\u00c3\7R\2\2\u00c2")
        buf.write("\u00c4\t\4\2\2\u00c3\u00c2\3\2\2\2\u00c3\u00c4\3\2\2\2")
        buf.write("\u00c4\u00c5\3\2\2\2\u00c5\u00c6\5\f\7\2\u00c6\u00c7\7")
        buf.write("r\2\2\u00c7\u00d7\3\2\2\2\u00c8\u00ca\7S\2\2\u00c9\u00cb")
        buf.write("\t\4\2\2\u00ca\u00c9\3\2\2\2\u00ca\u00cb\3\2\2\2\u00cb")
        buf.write("\u00cc\3\2\2\2\u00cc\u00cd\5\f\7\2\u00cd\u00ce\7r\2\2")
        buf.write("\u00ce\u00d7\3\2\2\2\u00cf\u00d1\7F\2\2\u00d0\u00d2\7")
        buf.write("i\2\2\u00d1\u00d0\3\2\2\2\u00d1\u00d2\3\2\2\2\u00d2\u00d3")
        buf.write("\3\2\2\2\u00d3\u00d4\5\f\7\2\u00d4\u00d5\7r\2\2\u00d5")
        buf.write("\u00d7\3\2\2\2\u00d6\u00ac\3\2\2\2\u00d6\u00b3\3\2\2\2")
        buf.write("\u00d6\u00ba\3\2\2\2\u00d6\u00c1\3\2\2\2\u00d6\u00c8\3")
        buf.write("\2\2\2\u00d6\u00cf\3\2\2\2\u00d7\13\3\2\2\2\u00d8\u00d9")
        buf.write("\5\16\b\2\u00d9\u00da\7\3\2\2\u00da\u00dc\3\2\2\2\u00db")
        buf.write("\u00d8\3\2\2\2\u00dc\u00df\3\2\2\2\u00dd\u00db\3\2\2\2")
        buf.write("\u00dd\u00de\3\2\2\2\u00de\r\3\2\2\2\u00df\u00dd\3\2\2")
        buf.write("\2\u00e0\u00e2\5v<\2\u00e1\u00e0\3\2\2\2\u00e1\u00e2\3")
        buf.write("\2\2\2\u00e2\u00e4\3\2\2\2\u00e3\u00e5\5\20\t\2\u00e4")
        buf.write("\u00e3\3\2\2\2\u00e4\u00e5\3\2\2\2\u00e5\u00e6\3\2\2\2")
        buf.write("\u00e6\u00e7\7\4\2\2\u00e7\u00e8\5\24\13\2\u00e8\u00e9")
        buf.write("\7\5\2\2\u00e9\u00ea\5\22\n\2\u00ea\u00fb\3\2\2\2\u00eb")
        buf.write("\u00ed\5v<\2\u00ec\u00eb\3\2\2\2\u00ec\u00ed\3\2\2\2\u00ed")
        buf.write("\u00ef\3\2\2\2\u00ee\u00f0\5\20\t\2\u00ef\u00ee\3\2\2")
        buf.write("\2\u00ef\u00f0\3\2\2\2\u00f0\u00f1\3\2\2\2\u00f1\u00f2")
        buf.write("\7\4\2\2\u00f2\u00fb\5\24\13\2\u00f3\u00f5\5v<\2\u00f4")
        buf.write("\u00f3\3\2\2\2\u00f4\u00f5\3\2\2\2\u00f5\u00f6\3\2\2\2")
        buf.write("\u00f6\u00f7\7\4\2\2\u00f7\u00f8\5\24\13\2\u00f8\u00f9")
        buf.write("\5\20\t\2\u00f9\u00fb\3\2\2\2\u00fa\u00e1\3\2\2\2\u00fa")
        buf.write("\u00ec\3\2\2\2\u00fa\u00f4\3\2\2\2\u00fb\17\3\2\2\2\u00fc")
        buf.write("\u00fd\7\u00fb\2\2\u00fd\u00fe\7\u010f\2\2\u00fe\21\3")
        buf.write("\2\2\2\u00ff\u0100\5n8\2\u0100\23\3\2\2\2\u0101\u0103")
        buf.write("\t\5\2\2\u0102\u0104\t\6\2\2\u0103\u0102\3\2\2\2\u0103")
        buf.write("\u0104\3\2\2\2\u0104\u0112\3\2\2\2\u0105\u0112\7\u00a8")
        buf.write("\2\2\u0106\u0107\7\u008c\2\2\u0107\u0108\7\6\2\2\u0108")
        buf.write("\u0109\5l\67\2\u0109\u010a\7\7\2\2\u010a\u010b\5l\67\2")
        buf.write("\u010b\u010c\7\b\2\2\u010c\u010d\7\u0100\2\2\u010d\u010e")
        buf.write("\5\24\13\2\u010e\u0112\3\2\2\2\u010f\u0112\t\7\2\2\u0110")
        buf.write("\u0112\7\u0110\2\2\u0111\u0101\3\2\2\2\u0111\u0105\3\2")
        buf.write("\2\2\u0111\u0106\3\2\2\2\u0111\u010f\3\2\2\2\u0111\u0110")
        buf.write("\3\2\2\2\u0112\25\3\2\2\2\u0113\u0114\5\30\r\2\u0114\u0115")
        buf.write("\7\4\2\2\u0115\u0116\5\32\16\2\u0116\u011c\3\2\2\2\u0117")
        buf.write("\u0118\5\30\r\2\u0118\u0119\7\4\2\2\u0119\u011c\3\2\2")
        buf.write("\2\u011a\u011c\5\32\16\2\u011b\u0113\3\2\2\2\u011b\u0117")
        buf.write("\3\2\2\2\u011b\u011a\3\2\2\2\u011c\27\3\2\2\2\u011d\u011e")
        buf.write("\7\u0110\2\2\u011e\31\3\2\2\2\u011f\u0120\5\34\17\2\u0120")
        buf.write("\u0121\5\"\22\2\u0121\u0137\3\2\2\2\u0122\u0123\5 \21")
        buf.write("\2\u0123\u0124\5\"\22\2\u0124\u0137\3\2\2\2\u0125\u0126")
        buf.write("\5 \21\2\u0126\u0127\7\t\2\2\u0127\u0128\5\"\22\2\u0128")
        buf.write("\u0129\7\n\2\2\u0129\u0137\3\2\2\2\u012a\u0137\5\36\20")
        buf.write("\2\u012b\u012c\t\b\2\2\u012c\u0131\7\u0110\2\2\u012d\u012e")
        buf.write("\7\t\2\2\u012e\u012f\5*\26\2\u012f\u0130\7\n\2\2\u0130")
        buf.write("\u0132\3\2\2\2\u0131\u012d\3\2\2\2\u0131\u0132\3\2\2\2")
        buf.write("\u0132\u0137\3\2\2\2\u0133\u0134\t\t\2\2\u0134\u0137\5")
        buf.write("\30\r\2\u0135\u0137\t\n\2\2\u0136\u011f\3\2\2\2\u0136")
        buf.write("\u0122\3\2\2\2\u0136\u0125\3\2\2\2\u0136\u012a\3\2\2\2")
        buf.write("\u0136\u012b\3\2\2\2\u0136\u0133\3\2\2\2\u0136\u0135\3")
        buf.write("\2\2\2\u0137\33\3\2\2\2\u0138\u0139\t\13\2\2\u0139\35")
        buf.write("\3\2\2\2\u013a\u013e\7\u00cb\2\2\u013b\u013e\5\u0082B")
        buf.write("\2\u013c\u013e\5\u0084C\2\u013d\u013a\3\2\2\2\u013d\u013b")
        buf.write("\3\2\2\2\u013d\u013c\3\2\2\2\u013e\37\3\2\2\2\u013f\u0140")
        buf.write("\t\f\2\2\u0140!\3\2\2\2\u0141\u0142\7\t\2\2\u0142\u0144")
        buf.write("\5(\25\2\u0143\u0145\5$\23\2\u0144\u0143\3\2\2\2\u0144")
        buf.write("\u0145\3\2\2\2\u0145\u0146\3\2\2\2\u0146\u0147\7\n\2\2")
        buf.write("\u0147\u014a\3\2\2\2\u0148\u014a\5(\25\2\u0149\u0141\3")
        buf.write("\2\2\2\u0149\u0148\3\2\2\2\u014a#\3\2\2\2\u014b\u014d")
        buf.write("\5&\24\2\u014c\u014b\3\2\2\2\u014d\u014e\3\2\2\2\u014e")
        buf.write("\u014c\3\2\2\2\u014e\u014f\3\2\2\2\u014f%\3\2\2\2\u0150")
        buf.write("\u0151\5\32\16\2\u0151\'\3\2\2\2\u0152\u0153\b\25\1\2")
        buf.write("\u0153\u0158\5f\64\2\u0154\u0158\5v<\2\u0155\u0158\5|")
        buf.write("?\2\u0156\u0158\5~@\2\u0157\u0152\3\2\2\2\u0157\u0154")
        buf.write("\3\2\2\2\u0157\u0155\3\2\2\2\u0157\u0156\3\2\2\2\u0158")
        buf.write("\u015e\3\2\2\2\u0159\u015a\f\3\2\2\u015a\u015b\7\r\2\2")
        buf.write("\u015b\u015d\5l\67\2\u015c\u0159\3\2\2\2\u015d\u0160\3")
        buf.write("\2\2\2\u015e\u015c\3\2\2\2\u015e\u015f\3\2\2\2\u015f)")
        buf.write("\3\2\2\2\u0160\u015e\3\2\2\2\u0161\u0162\5,\27\2\u0162")
        buf.write("+\3\2\2\2\u0163\u0168\5.\30\2\u0164\u0165\7\16\2\2\u0165")
        buf.write("\u0167\5.\30\2\u0166\u0164\3\2\2\2\u0167\u016a\3\2\2\2")
        buf.write("\u0168\u0166\3\2\2\2\u0168\u0169\3\2\2\2\u0169-\3\2\2")
        buf.write("\2\u016a\u0168\3\2\2\2\u016b\u016d\5v<\2\u016c\u016b\3")
        buf.write("\2\2\2\u016c\u016d\3\2\2\2\u016d\u016e\3\2\2\2\u016e\u0170")
        buf.write("\7\5\2\2\u016f\u0171\5\"\22\2\u0170\u016f\3\2\2\2\u0170")
        buf.write("\u0171\3\2\2\2\u0171/\3\2\2\2\u0172\u0173\5\62\32\2\u0173")
        buf.write("\u0174\7\3\2\2\u0174\u0185\3\2\2\2\u0175\u0176\5\64\33")
        buf.write("\2\u0176\u0177\7\3\2\2\u0177\u0185\3\2\2\2\u0178\u0179")
        buf.write("\5F$\2\u0179\u017a\7\3\2\2\u017a\u0185\3\2\2\2\u017b\u017c")
        buf.write("\5X-\2\u017c\u017d\7\3\2\2\u017d\u0185\3\2\2\2\u017e\u017f")
        buf.write("\5R*\2\u017f\u0180\7\3\2\2\u0180\u0185\3\2\2\2\u0181\u0182")
        buf.write("\5Z.\2\u0182\u0183\7\3\2\2\u0183\u0185\3\2\2\2\u0184\u0172")
        buf.write("\3\2\2\2\u0184\u0175\3\2\2\2\u0184\u0178\3\2\2\2\u0184")
        buf.write("\u017b\3\2\2\2\u0184\u017e\3\2\2\2\u0184\u0181\3\2\2\2")
        buf.write("\u0185\61\3\2\2\2\u0186\u0187\5z>\2\u0187\u0188\7\5\2")
        buf.write("\2\u0188\u0189\5\\/\2\u0189\u0197\3\2\2\2\u018a\u018b")
        buf.write("\5|?\2\u018b\u018c\7\5\2\2\u018c\u018d\5\\/\2\u018d\u0197")
        buf.write("\3\2\2\2\u018e\u018f\5\u0080A\2\u018f\u0190\7\5\2\2\u0190")
        buf.write("\u0191\5\\/\2\u0191\u0197\3\2\2\2\u0192\u0193\5~@\2\u0193")
        buf.write("\u0194\7\5\2\2\u0194\u0195\5\\/\2\u0195\u0197\3\2\2\2")
        buf.write("\u0196\u0186\3\2\2\2\u0196\u018a\3\2\2\2\u0196\u018e\3")
        buf.write("\2\2\2\u0196\u0192\3\2\2\2\u0197\63\3\2\2\2\u0198\u019d")
        buf.write("\5\66\34\2\u0199\u019d\58\35\2\u019a\u019d\5:\36\2\u019b")
        buf.write("\u019d\5<\37\2\u019c\u0198\3\2\2\2\u019c\u0199\3\2\2\2")
        buf.write("\u019c\u019a\3\2\2\2\u019c\u019b\3\2\2\2\u019d\65\3\2")
        buf.write("\2\2\u019e\u019f\7\u010d\2\2\u019f\u01a0\5^\60\2\u01a0")
        buf.write("\u01a1\7\u00be\2\2\u01a1\u01a2\5D#\2\u01a2\u01a3\7\u0085")
        buf.write("\2\2\u01a3\67\3\2\2\2\u01a4\u01a5\7\u010d\2\2\u01a5\u01a6")
        buf.write("\5^\60\2\u01a6\u01a7\7\u00be\2\2\u01a7\u01a8\5D#\2\u01a8")
        buf.write("\u01a9\5> \2\u01a9\u01aa\7\u0085\2\2\u01aa9\3\2\2\2\u01ab")
        buf.write("\u01ac\7\u010d\2\2\u01ac\u01ad\5^\60\2\u01ad\u01ae\7\u00be")
        buf.write("\2\2\u01ae\u01af\5D#\2\u01af\u01b0\5B\"\2\u01b0\u01b1")
        buf.write("\7\u0085\2\2\u01b1;\3\2\2\2\u01b2\u01b3\7\u010d\2\2\u01b3")
        buf.write("\u01b4\5^\60\2\u01b4\u01b5\7\u00be\2\2\u01b5\u01b6\5D")
        buf.write("#\2\u01b6\u01b7\5> \2\u01b7\u01b8\5B\"\2\u01b8\u01b9\7")
        buf.write("\u0085\2\2\u01b9=\3\2\2\2\u01ba\u01bc\5@!\2\u01bb\u01ba")
        buf.write("\3\2\2\2\u01bc\u01bd\3\2\2\2\u01bd\u01bb\3\2\2\2\u01bd")
        buf.write("\u01be\3\2\2\2\u01be?\3\2\2\2\u01bf\u01c0\7\u009c\2\2")
        buf.write("\u01c0\u01c1\5^\60\2\u01c1\u01c2\7\u00be\2\2\u01c2\u01c3")
        buf.write("\5D#\2\u01c3A\3\2\2\2\u01c4\u01c5\7\u00bf\2\2\u01c5\u01c6")
        buf.write("\5D#\2\u01c6C\3\2\2\2\u01c7\u01c9\5\60\31\2\u01c8\u01c7")
        buf.write("\3\2\2\2\u01c9\u01ca\3\2\2\2\u01ca\u01c8\3\2\2\2\u01ca")
        buf.write("\u01cb\3\2\2\2\u01cbE\3\2\2\2\u01cc\u01cd\7\u00a4\2\2")
        buf.write("\u01cd\u01ce\5\\/\2\u01ce\u01cf\7\u0100\2\2\u01cf\u01d2")
        buf.write("\5H%\2\u01d0\u01d1\7\u00bf\2\2\u01d1\u01d3\5D#\2\u01d2")
        buf.write("\u01d0\3\2\2\2\u01d2\u01d3\3\2\2\2\u01d3\u01d4\3\2\2\2")
        buf.write("\u01d4\u01d5\7b\2\2\u01d5G\3\2\2\2\u01d6\u01d8\5J&\2\u01d7")
        buf.write("\u01d6\3\2\2\2\u01d8\u01d9\3\2\2\2\u01d9\u01d7\3\2\2\2")
        buf.write("\u01d9\u01da\3\2\2\2\u01daI\3\2\2\2\u01db\u01dc\5L\'\2")
        buf.write("\u01dc\u01dd\7\4\2\2\u01dd\u01de\5D#\2\u01deK\3\2\2\2")
        buf.write("\u01df\u01e4\5N(\2\u01e0\u01e1\7\16\2\2\u01e1\u01e3\5")
        buf.write("N(\2\u01e2\u01e0\3\2\2\2\u01e3\u01e6\3\2\2\2\u01e4\u01e2")
        buf.write("\3\2\2\2\u01e4\u01e5\3\2\2\2\u01e5M\3\2\2\2\u01e6\u01e4")
        buf.write("\3\2\2\2\u01e7\u01e8\5n8\2\u01e8\u01e9\7\7\2\2\u01e9\u01ea")
        buf.write("\5n8\2\u01ea\u01ed\3\2\2\2\u01eb\u01ed\5\\/\2\u01ec\u01e7")
        buf.write("\3\2\2\2\u01ec\u01eb\3\2\2\2\u01edO\3\2\2\2\u01ee\u01f4")
        buf.write("\5R*\2\u01ef\u01f4\5X-\2\u01f0\u01f4\5Z.\2\u01f1\u01f4")
        buf.write("\7\u00a3\2\2\u01f2\u01f4\7e\2\2\u01f3\u01ee\3\2\2\2\u01f3")
        buf.write("\u01ef\3\2\2\2\u01f3\u01f0\3\2\2\2\u01f3\u01f1\3\2\2\2")
        buf.write("\u01f3\u01f2\3\2\2\2\u01f4Q\3\2\2\2\u01f5\u01f6\7\u00c9")
        buf.write("\2\2\u01f6\u01f7\5T+\2\u01f7\u01f8\7\5\2\2\u01f8\u01f9")
        buf.write("\5V,\2\u01f9\u01fd\7\u00f6\2\2\u01fa\u01fc\5\60\31\2\u01fb")
        buf.write("\u01fa\3\2\2\2\u01fc\u01ff\3\2\2\2\u01fd\u01fb\3\2\2\2")
        buf.write("\u01fd\u01fe\3\2\2\2\u01fe\u0200\3\2\2\2\u01ff\u01fd\3")
        buf.write("\2\2\2\u0200\u0201\7u\2\2\u0201S\3\2\2\2\u0202\u0203\7")
        buf.write("\u0110\2\2\u0203U\3\2\2\2\u0204\u0205\5\\/\2\u0205\u0206")
        buf.write("\7\u0102\2\2\u0206\u0209\5\\/\2\u0207\u0208\7\u00f5\2")
        buf.write("\2\u0208\u020a\5\\/\2\u0209\u0207\3\2\2\2\u0209\u020a")
        buf.write("\3\2\2\2\u020aW\3\2\2\2\u020b\u020c\7\u009d\2\2\u020c")
        buf.write("\u020d\5\\/\2\u020d\u020e\7\u00f6\2\2\u020e\u020f\5D#")
        buf.write("\2\u020f\u0210\7Z\2\2\u0210Y\3\2\2\2\u0211\u0215\7\u0086")
        buf.write("\2\2\u0212\u0214\5\60\31\2\u0213\u0212\3\2\2\2\u0214\u0217")
        buf.write("\3\2\2\2\u0215\u0213\3\2\2\2\u0215\u0216\3\2\2\2\u0216")
        buf.write("\u0218\3\2\2\2\u0217\u0215\3\2\2\2\u0218\u0219\7\u009e")
        buf.write("\2\2\u0219\u021a\5\\/\2\u021a\u021b\7Y\2\2\u021b[\3\2")
        buf.write("\2\2\u021c\u021f\5^\60\2\u021d\u021f\5`\61\2\u021e\u021c")
        buf.write("\3\2\2\2\u021e\u021d\3\2\2\2\u021f]\3\2\2\2\u0220\u0221")
        buf.write("\b\60\1\2\u0221\u0222\5`\61\2\u0222\u0223\t\r\2\2\u0223")
        buf.write("\u0224\5`\61\2\u0224\u0232\3\2\2\2\u0225\u0226\7\u00cb")
        buf.write("\2\2\u0226\u0232\5^\60\6\u0227\u0228\5\u0082B\2\u0228")
        buf.write("\u0229\7\t\2\2\u0229\u022a\5`\61\2\u022a\u022b\7\n\2\2")
        buf.write("\u022b\u0232\3\2\2\2\u022c\u0232\5d\63\2\u022d\u022e\7")
        buf.write("\t\2\2\u022e\u022f\5^\60\2\u022f\u0230\7\n\2\2\u0230\u0232")
        buf.write("\3\2\2\2\u0231\u0220\3\2\2\2\u0231\u0225\3\2\2\2\u0231")
        buf.write("\u0227\3\2\2\2\u0231\u022c\3\2\2\2\u0231\u022d\3\2\2\2")
        buf.write("\u0232\u0238\3\2\2\2\u0233\u0234\f\b\2\2\u0234\u0235\t")
        buf.write("\16\2\2\u0235\u0237\5^\60\t\u0236\u0233\3\2\2\2\u0237")
        buf.write("\u023a\3\2\2\2\u0238\u0236\3\2\2\2\u0238\u0239\3\2\2\2")
        buf.write("\u0239_\3\2\2\2\u023a\u0238\3\2\2\2\u023b\u023c\b\61\1")
        buf.write("\2\u023c\u023d\7\30\2\2\u023d\u0261\5`\61\b\u023e\u023f")
        buf.write("\5\u0082B\2\u023f\u0242\7\t\2\2\u0240\u0243\5^\60\2\u0241")
        buf.write("\u0243\5`\61\2\u0242\u0240\3\2\2\2\u0242\u0241\3\2\2\2")
        buf.write("\u0243\u0244\3\2\2\2\u0244\u0245\7\n\2\2\u0245\u0261\3")
        buf.write("\2\2\2\u0246\u0247\5\u0084C\2\u0247\u024a\7\t\2\2\u0248")
        buf.write("\u024b\5^\60\2\u0249\u024b\5`\61\2\u024a\u0248\3\2\2\2")
        buf.write("\u024a\u0249\3\2\2\2\u024b\u024c\3\2\2\2\u024c\u024d\7")
        buf.write("\n\2\2\u024d\u0261\3\2\2\2\u024e\u024f\5x=\2\u024f\u0256")
        buf.write("\7\t\2\2\u0250\u0252\5b\62\2\u0251\u0253\7\16\2\2\u0252")
        buf.write("\u0251\3\2\2\2\u0252\u0253\3\2\2\2\u0253\u0255\3\2\2\2")
        buf.write("\u0254\u0250\3\2\2\2\u0255\u0258\3\2\2\2\u0256\u0254\3")
        buf.write("\2\2\2\u0256\u0257\3\2\2\2\u0257\u0259\3\2\2\2\u0258\u0256")
        buf.write("\3\2\2\2\u0259\u025a\7\n\2\2\u025a\u0261\3\2\2\2\u025b")
        buf.write("\u0261\5d\63\2\u025c\u025d\7\t\2\2\u025d\u025e\5`\61\2")
        buf.write("\u025e\u025f\7\n\2\2\u025f\u0261\3\2\2\2\u0260\u023b\3")
        buf.write("\2\2\2\u0260\u023e\3\2\2\2\u0260\u0246\3\2\2\2\u0260\u024e")
        buf.write("\3\2\2\2\u0260\u025b\3\2\2\2\u0260\u025c\3\2\2\2\u0261")
        buf.write("\u026a\3\2\2\2\u0262\u0263\f\n\2\2\u0263\u0264\t\17\2")
        buf.write("\2\u0264\u0269\5`\61\13\u0265\u0266\f\t\2\2\u0266\u0267")
        buf.write("\t\20\2\2\u0267\u0269\5`\61\n\u0268\u0262\3\2\2\2\u0268")
        buf.write("\u0265\3\2\2\2\u0269\u026c\3\2\2\2\u026a\u0268\3\2\2\2")
        buf.write("\u026a\u026b\3\2\2\2\u026ba\3\2\2\2\u026c\u026a\3\2\2")
        buf.write("\2\u026d\u026e\5v<\2\u026e\u0271\7\5\2\2\u026f\u0272\5")
        buf.write("v<\2\u0270\u0272\5f\64\2\u0271\u026f\3\2\2\2\u0271\u0270")
        buf.write("\3\2\2\2\u0272c\3\2\2\2\u0273\u0278\5z>\2\u0274\u0278")
        buf.write("\5|?\2\u0275\u0278\5~@\2\u0276\u0278\5f\64\2\u0277\u0273")
        buf.write("\3\2\2\2\u0277\u0274\3\2\2\2\u0277\u0275\3\2\2\2\u0277")
        buf.write("\u0276\3\2\2\2\u0278e\3\2\2\2\u0279\u027d\5h\65\2\u027a")
        buf.write("\u027d\5t;\2\u027b\u027d\5r:\2\u027c\u0279\3\2\2\2\u027c")
        buf.write("\u027a\3\2\2\2\u027c\u027b\3\2\2\2\u027dg\3\2\2\2\u027e")
        buf.write("\u0281\5j\66\2\u027f\u0281\5p9\2\u0280\u027e\3\2\2\2\u0280")
        buf.write("\u027f\3\2\2\2\u0281i\3\2\2\2\u0282\u0283\t\21\2\2\u0283")
        buf.write("\u0285\7\31\2\2\u0284\u0282\3\2\2\2\u0284\u0285\3\2\2")
        buf.write("\2\u0285\u028a\3\2\2\2\u0286\u028b\5n8\2\u0287\u028b\7")
        buf.write("\u0113\2\2\u0288\u028b\7\u0114\2\2\u0289\u028b\7\u0115")
        buf.write("\2\2\u028a\u0286\3\2\2\2\u028a\u0287\3\2\2\2\u028a\u0288")
        buf.write("\3\2\2\2\u028a\u0289\3\2\2\2\u028bk\3\2\2\2\u028c\u0293")
        buf.write("\7\u0112\2\2\u028d\u028f\7\32\2\2\u028e\u028d\3\2\2\2")
        buf.write("\u028e\u028f\3\2\2\2\u028f\u0290\3\2\2\2\u0290\u0292\7")
        buf.write("\u0112\2\2\u0291\u028e\3\2\2\2\u0292\u0295\3\2\2\2\u0293")
        buf.write("\u0291\3\2\2\2\u0293\u0294\3\2\2\2\u0294m\3\2\2\2\u0295")
        buf.write("\u0293\3\2\2\2\u0296\u0298\t\20\2\2\u0297\u0296\3\2\2")
        buf.write("\2\u0297\u0298\3\2\2\2\u0298\u0299\3\2\2\2\u0299\u029a")
        buf.write("\5l\67\2\u029ao\3\2\2\2\u029b\u029f\7\u00a7\2\2\u029c")
        buf.write("\u029d\7\u0096\2\2\u029d\u029f\7\31\2\2\u029e\u029b\3")
        buf.write("\2\2\2\u029e\u029c\3\2\2\2\u029e\u029f\3\2\2\2\u029f\u02a0")
        buf.write("\3\2\2\2\u02a0\u02a1\5n8\2\u02a1\u02a2\7\r\2\2\u02a2\u02a5")
        buf.write("\5l\67\2\u02a3\u02a4\7\33\2\2\u02a4\u02a6\5n8\2\u02a5")
        buf.write("\u02a3\3\2\2\2\u02a5\u02a6\3\2\2\2\u02a6q\3\2\2\2\u02a7")
        buf.write("\u02a8\7\u00af\2\2\u02a8\u02aa\7\31\2\2\u02a9\u02a7\3")
        buf.write("\2\2\2\u02a9\u02aa\3\2\2\2\u02aa\u02ab\3\2\2\2\u02ab\u02ac")
        buf.write("\t\22\2\2\u02acs\3\2\2\2\u02ad\u02ae\t\23\2\2\u02aeu\3")
        buf.write("\2\2\2\u02af\u02b0\7\u0110\2\2\u02b0w\3\2\2\2\u02b1\u02b2")
        buf.write("\7\u0110\2\2\u02b2y\3\2\2\2\u02b3\u02b4\5v<\2\u02b4{\3")
        buf.write("\2\2\2\u02b5\u02b6\5v<\2\u02b6\u02b7\7\6\2\2\u02b7\u02b8")
        buf.write("\5`\61\2\u02b8\u02b9\7\b\2\2\u02b9}\3\2\2\2\u02ba\u02bd")
        buf.write("\5v<\2\u02bb\u02bd\5|?\2\u02bc\u02ba\3\2\2\2\u02bc\u02bb")
        buf.write("\3\2\2\2\u02bd\u02be\3\2\2\2\u02be\u02bf\7\r\2\2\u02bf")
        buf.write("\u02c1\3\2\2\2\u02c0\u02bc\3\2\2\2\u02c1\u02c2\3\2\2\2")
        buf.write("\u02c2\u02c0\3\2\2\2\u02c2\u02c3\3\2\2\2\u02c3\u02c6\3")
        buf.write("\2\2\2\u02c4\u02c7\5v<\2\u02c5\u02c7\5|?\2\u02c6\u02c4")
        buf.write("\3\2\2\2\u02c6\u02c5\3\2\2\2\u02c7\177\3\2\2\2\u02c8\u02c9")
        buf.write("\5v<\2\u02c9\u02ca\7\r\2\2\u02ca\u02cb\5l\67\2\u02cb\u0081")
        buf.write("\3\2\2\2\u02cc\u02cd\t\24\2\2\u02cd\u0083\3\2\2\2\u02ce")
        buf.write("\u02cf\t\25\2\2\u02cf\u0085\3\2\2\2M\u0089\u008c\u0092")
        buf.write("\u0095\u0098\u009b\u00a2\u00a5\u00aa\u00ae\u00b5\u00bc")
        buf.write("\u00c3\u00ca\u00d1\u00d6\u00dd\u00e1\u00e4\u00ec\u00ef")
        buf.write("\u00f4\u00fa\u0103\u0111\u011b\u0131\u0136\u013d\u0144")
        buf.write("\u0149\u014e\u0157\u015e\u0168\u016c\u0170\u0184\u0196")
        buf.write("\u019c\u01bd\u01ca\u01d2\u01d9\u01e4\u01ec\u01f3\u01fd")
        buf.write("\u0209\u0215\u021e\u0231\u0238\u0242\u024a\u0252\u0256")
        buf.write("\u0260\u0268\u026a\u0271\u0277\u027c\u0280\u0284\u028a")
        buf.write("\u028e\u0293\u0297\u029e\u02a5\u02a9\u02bc\u02c2\u02c6")
        return buf.getvalue()


class IEC61131ParserParser ( Parser ):

    grammarFileName = "IEC61131Parser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "':'", "':='", "'['", "'..'", "']'", 
                     "'('", "')'", "'R'", "'S'", "'.'", "','", "'>='", "'<='", 
                     "'='", "'<'", "'>'", "'<>'", "'*'", "'/'", "'+'", "'-'", 
                     "'#'", "'_'", "'E'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "IEC_COMMENT", "C_COMMENT", 
                      "LINE_COMMENT", "UDINT_TO_USINT", "USINT_TO_UDINT", 
                      "DINT_TO_UDINT", "UDINT_TO_DINT", "UINT_TO_USINT", 
                      "USINT_TO_BYTE", "BYTE_TO_USINT", "USINT_TO_UINT", 
                      "USINT_TO_DINT", "DINT_TO_USINT", "BYTE_TO_WORD", 
                      "BYTE_TO_UINT", "WORD_TO_BYTE", "WORD_TO_UINT", "REAL_TO_UINT", 
                      "INT_TO_USINT", "UINT_TO_BOOL", "UINT_TO_WORD", "UINT_TO_REAL", 
                      "DINT_TO_UINT", "UINT_TO_DINT", "WORD_TO_INT", "REAL_TO_INT", 
                      "INT_TO_BOOL", "BOOL_TO_INT", "INT_TO_WORD", "INT_TO_REAL", 
                      "INT_TO_UINT", "UINT_TO_INT", "END_FUNCTION_BLOCK", 
                      "END_CONFIGURATION", "END_TRANSITION", "LOC_PARTLY_VAR", 
                      "FUNCTION_BLOCK", "END_INTERFACE", "CONFIGURATION", 
                      "MULTIBIT_PART", "DATE_AND_TIME", "END_NAMESPACE", 
                      "VAR_EXTERNAL", "END_FUNCTION", "END_RESOURCE", "INITIAL_STEP", 
                      "TIME_OF_DAY", "END_PROGRAM", "END_ACTION", "END_METHOD", 
                      "TRANSITION", "VAR_GLOBAL", "NON_RETAIN", "NAMESPACE", 
                      "VAR_OUTPUT", "VAR_IN_OUT", "VAR_ACCESS", "END_STRUCT", 
                      "READ_WRITE", "IMPLEMENTS", "VAR_CONFIG", "END_REPEAT", 
                      "END_WHILE", "READ_ONLY", "PROTECTED", "VAR_INPUT", 
                      "END_CLASS", "INTERFACE", "ABSTRACT", "FUNCTION", 
                      "END_CASE", "RESOURCE", "INTERNAL", "CONTINUE", "PRIORITY", 
                      "BOOL_EXP", "END_STEP", "CONSTANT", "OVERRIDE", "VAR_TEMP", 
                      "END_TYPE", "INTERVAL", "EXTENDS", "PRIVATE", "TIME_MS", 
                      "PROGRAM", "END_VAR", "WSTRING", "OVERLAP", "END_FOR", 
                      "REPLACE", "PUBLIC", "METHOD", "ACTION", "RETURN", 
                      "STRING", "STRUCT", "RETAIN", "TIME_S", "R_EDGE", 
                      "F_EDGE", "R_TRIG", "F_TRIG", "REF_TO", "SINGLE", 
                      "END_IF", "REPEAT", "INSERT", "DELETE", "CONCAT", 
                      "FINAL", "SUPER", "ARRAY", "WCHAR", "USING", "CLASS", 
                      "FALSE", "DWORD", "LWORD", "USINT", "UDINT", "ULINT", 
                      "LREAL", "LTIME", "LDATE", "CALCN", "RETCN", "JMPCN", 
                      "ELSIF", "WHILE", "UNTIL", "RIGHT", "LIMIT", "TRUNC", 
                      "ATAN2", "EXIT", "CASE", "THIS", "TASK", "REAL", "TIME", 
                      "DATE", "LTOD", "BYTE", "WORD", "CALC", "TRUE", "BOOL", 
                      "WITH", "STEP", "CHAR", "TYPE", "NULL", "FROM", "UINT", 
                      "SINT", "DINT", "LINT", "ANDN", "XORN", "RETC", "JMPC", 
                      "THEN", "ELSE", "CTUD", "SQRT", "ASIN", "ACOS", "ATAN", 
                      "EXPT", "MOVE", "LEFT", "FIND", "FOR", "INT", "NOT", 
                      "MUL", "ADD", "TOD", "LDT", "VAR", "CAL", "CLK", "STN", 
                      "LDN", "AND", "XOR", "ORN", "SUB", "MOD", "DIV", "RET", 
                      "REF", "JMP", "CTU", "CTD", "TON", "TOF", "ABS", "LOG", 
                      "EXP", "SIN", "COS", "TAN", "SHL", "SHR", "ROL", "ROR", 
                      "SEL", "MAX", "MIN", "MUX", "LEN", "MID", "TP", "SR", 
                      "RS", "BY", "DO", "SD", "DS", "SL", "DT", "AT", "CU", 
                      "PV", "PT", "IN", "OF", "LD", "TO", "ON", "ST", "CD", 
                      "OR", "GT", "GE", "EQ", "LT", "LE", "NE", "IF", "LN", 
                      "DIRECTVARIABLE", "IDENTIFIER", "LETTER", "DIGITS", 
                      "BINARY_INT", "OCTAL_INT", "HEX_INT", "WS", "PRAGMA", 
                      "ErrorCharacter" ]

    RULE_pou_decl = 0
    RULE_fb_std_names = 1
    RULE_body = 2
    RULE_variable_blocks = 3
    RULE_variable_block = 4
    RULE_variable_decls = 5
    RULE_variable_decl = 6
    RULE_located_at = 7
    RULE_variable_init = 8
    RULE_data_type = 9
    RULE_instruction = 10
    RULE_label = 11
    RULE_il_instruction = 12
    RULE_il_instr_op = 13
    RULE_il_expr_uop = 14
    RULE_il_expr_bop = 15
    RULE_il_expr = 16
    RULE_il_instruction_list = 17
    RULE_il_instruction_one = 18
    RULE_il_expr_simple = 19
    RULE_il_call_pars = 20
    RULE_il_call_args = 21
    RULE_il_call_arg = 22
    RULE_st_stmt = 23
    RULE_assign_stmt = 24
    RULE_if_stmt = 25
    RULE_if_simple_stmt = 26
    RULE_if_elseif_stmt = 27
    RULE_if_else_stmt = 28
    RULE_if_complete_stmt = 29
    RULE_elsif_stmt_list = 30
    RULE_elsif_stmt = 31
    RULE_else_stmt = 32
    RULE_stmt_block = 33
    RULE_case_stmt = 34
    RULE_case_selections = 35
    RULE_case_selection = 36
    RULE_case_list = 37
    RULE_case_list_elem = 38
    RULE_iteration_stmt = 39
    RULE_for_stmt = 40
    RULE_control_variable = 41
    RULE_for_list = 42
    RULE_while_stmt = 43
    RULE_repeat_stmt = 44
    RULE_expression = 45
    RULE_bool_expression = 46
    RULE_term_expression = 47
    RULE_func_param_init = 48
    RULE_leaf_expression = 49
    RULE_constant = 50
    RULE_numeric_literal = 51
    RULE_int_literal = 52
    RULE_uns_int = 53
    RULE_signed_int = 54
    RULE_real_literal = 55
    RULE_bool_literal = 56
    RULE_time_literal = 57
    RULE_variable_name = 58
    RULE_custom_func_name = 59
    RULE_simple_var = 60
    RULE_array_access = 61
    RULE_composite_access = 62
    RULE_variable_bit_access = 63
    RULE_conversion_function = 64
    RULE_std_func_name = 65

    ruleNames =  [ "pou_decl", "fb_std_names", "body", "variable_blocks", 
                   "variable_block", "variable_decls", "variable_decl", 
                   "located_at", "variable_init", "data_type", "instruction", 
                   "label", "il_instruction", "il_instr_op", "il_expr_uop", 
                   "il_expr_bop", "il_expr", "il_instruction_list", "il_instruction_one", 
                   "il_expr_simple", "il_call_pars", "il_call_args", "il_call_arg", 
                   "st_stmt", "assign_stmt", "if_stmt", "if_simple_stmt", 
                   "if_elseif_stmt", "if_else_stmt", "if_complete_stmt", 
                   "elsif_stmt_list", "elsif_stmt", "else_stmt", "stmt_block", 
                   "case_stmt", "case_selections", "case_selection", "case_list", 
                   "case_list_elem", "iteration_stmt", "for_stmt", "control_variable", 
                   "for_list", "while_stmt", "repeat_stmt", "expression", 
                   "bool_expression", "term_expression", "func_param_init", 
                   "leaf_expression", "constant", "numeric_literal", "int_literal", 
                   "uns_int", "signed_int", "real_literal", "bool_literal", 
                   "time_literal", "variable_name", "custom_func_name", 
                   "simple_var", "array_access", "composite_access", "variable_bit_access", 
                   "conversion_function", "std_func_name" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    IEC_COMMENT=26
    C_COMMENT=27
    LINE_COMMENT=28
    UDINT_TO_USINT=29
    USINT_TO_UDINT=30
    DINT_TO_UDINT=31
    UDINT_TO_DINT=32
    UINT_TO_USINT=33
    USINT_TO_BYTE=34
    BYTE_TO_USINT=35
    USINT_TO_UINT=36
    USINT_TO_DINT=37
    DINT_TO_USINT=38
    BYTE_TO_WORD=39
    BYTE_TO_UINT=40
    WORD_TO_BYTE=41
    WORD_TO_UINT=42
    REAL_TO_UINT=43
    INT_TO_USINT=44
    UINT_TO_BOOL=45
    UINT_TO_WORD=46
    UINT_TO_REAL=47
    DINT_TO_UINT=48
    UINT_TO_DINT=49
    WORD_TO_INT=50
    REAL_TO_INT=51
    INT_TO_BOOL=52
    BOOL_TO_INT=53
    INT_TO_WORD=54
    INT_TO_REAL=55
    INT_TO_UINT=56
    UINT_TO_INT=57
    END_FUNCTION_BLOCK=58
    END_CONFIGURATION=59
    END_TRANSITION=60
    LOC_PARTLY_VAR=61
    FUNCTION_BLOCK=62
    END_INTERFACE=63
    CONFIGURATION=64
    MULTIBIT_PART=65
    DATE_AND_TIME=66
    END_NAMESPACE=67
    VAR_EXTERNAL=68
    END_FUNCTION=69
    END_RESOURCE=70
    INITIAL_STEP=71
    TIME_OF_DAY=72
    END_PROGRAM=73
    END_ACTION=74
    END_METHOD=75
    TRANSITION=76
    VAR_GLOBAL=77
    NON_RETAIN=78
    NAMESPACE=79
    VAR_OUTPUT=80
    VAR_IN_OUT=81
    VAR_ACCESS=82
    END_STRUCT=83
    READ_WRITE=84
    IMPLEMENTS=85
    VAR_CONFIG=86
    END_REPEAT=87
    END_WHILE=88
    READ_ONLY=89
    PROTECTED=90
    VAR_INPUT=91
    END_CLASS=92
    INTERFACE=93
    ABSTRACT=94
    FUNCTION=95
    END_CASE=96
    RESOURCE=97
    INTERNAL=98
    CONTINUE=99
    PRIORITY=100
    BOOL_EXP=101
    END_STEP=102
    CONSTANT=103
    OVERRIDE=104
    VAR_TEMP=105
    END_TYPE=106
    INTERVAL=107
    EXTENDS=108
    PRIVATE=109
    TIME_MS=110
    PROGRAM=111
    END_VAR=112
    WSTRING=113
    OVERLAP=114
    END_FOR=115
    REPLACE=116
    PUBLIC=117
    METHOD=118
    ACTION=119
    RETURN=120
    STRING=121
    STRUCT=122
    RETAIN=123
    TIME_S=124
    R_EDGE=125
    F_EDGE=126
    R_TRIG=127
    F_TRIG=128
    REF_TO=129
    SINGLE=130
    END_IF=131
    REPEAT=132
    INSERT=133
    DELETE=134
    CONCAT=135
    FINAL=136
    SUPER=137
    ARRAY=138
    WCHAR=139
    USING=140
    CLASS=141
    FALSE=142
    DWORD=143
    LWORD=144
    USINT=145
    UDINT=146
    ULINT=147
    LREAL=148
    LTIME=149
    LDATE=150
    CALCN=151
    RETCN=152
    JMPCN=153
    ELSIF=154
    WHILE=155
    UNTIL=156
    RIGHT=157
    LIMIT=158
    TRUNC=159
    ATAN2=160
    EXIT=161
    CASE=162
    THIS=163
    TASK=164
    REAL=165
    TIME=166
    DATE=167
    LTOD=168
    BYTE=169
    WORD=170
    CALC=171
    TRUE=172
    BOOL=173
    WITH=174
    STEP=175
    CHAR=176
    TYPE=177
    NULL=178
    FROM=179
    UINT=180
    SINT=181
    DINT=182
    LINT=183
    ANDN=184
    XORN=185
    RETC=186
    JMPC=187
    THEN=188
    ELSE=189
    CTUD=190
    SQRT=191
    ASIN=192
    ACOS=193
    ATAN=194
    EXPT=195
    MOVE=196
    LEFT=197
    FIND=198
    FOR=199
    INT=200
    NOT=201
    MUL=202
    ADD=203
    TOD=204
    LDT=205
    VAR=206
    CAL=207
    CLK=208
    STN=209
    LDN=210
    AND=211
    XOR=212
    ORN=213
    SUB=214
    MOD=215
    DIV=216
    RET=217
    REF=218
    JMP=219
    CTU=220
    CTD=221
    TON=222
    TOF=223
    ABS=224
    LOG=225
    EXP=226
    SIN=227
    COS=228
    TAN=229
    SHL=230
    SHR=231
    ROL=232
    ROR=233
    SEL=234
    MAX=235
    MIN=236
    MUX=237
    LEN=238
    MID=239
    TP=240
    SR=241
    RS=242
    BY=243
    DO=244
    SD=245
    DS=246
    SL=247
    DT=248
    AT=249
    CU=250
    PV=251
    PT=252
    IN=253
    OF=254
    LD=255
    TO=256
    ON=257
    ST=258
    CD=259
    OR=260
    GT=261
    GE=262
    EQ=263
    LT=264
    LE=265
    NE=266
    IF=267
    LN=268
    DIRECTVARIABLE=269
    IDENTIFIER=270
    LETTER=271
    DIGITS=272
    BINARY_INT=273
    OCTAL_INT=274
    HEX_INT=275
    WS=276
    PRAGMA=277
    ErrorCharacter=278

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Pou_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_pou_decl

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class FbDeclContext(Pou_declContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Pou_declContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FUNCTION_BLOCK(self):
            return self.getToken(IEC61131ParserParser.FUNCTION_BLOCK, 0)
        def END_FUNCTION_BLOCK(self):
            return self.getToken(IEC61131ParserParser.END_FUNCTION_BLOCK, 0)
        def IDENTIFIER(self):
            return self.getToken(IEC61131ParserParser.IDENTIFIER, 0)
        def fb_std_names(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Fb_std_namesContext,0)

        def variable_blocks(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_blocksContext,0)

        def body(self):
            return self.getTypedRuleContext(IEC61131ParserParser.BodyContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFbDecl" ):
                return visitor.visitFbDecl(self)
            else:
                return visitor.visitChildren(self)


    class ProgramDeclContext(Pou_declContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Pou_declContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PROGRAM(self):
            return self.getToken(IEC61131ParserParser.PROGRAM, 0)
        def IDENTIFIER(self):
            return self.getToken(IEC61131ParserParser.IDENTIFIER, 0)
        def END_PROGRAM(self):
            return self.getToken(IEC61131ParserParser.END_PROGRAM, 0)
        def variable_blocks(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_blocksContext,0)

        def body(self):
            return self.getTypedRuleContext(IEC61131ParserParser.BodyContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgramDecl" ):
                return visitor.visitProgramDecl(self)
            else:
                return visitor.visitChildren(self)



    def pou_decl(self):

        localctx = IEC61131ParserParser.Pou_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_pou_decl)
        self._la = 0 # Token type
        try:
            self.state = 153
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IEC61131ParserParser.PROGRAM]:
                localctx = IEC61131ParserParser.ProgramDeclContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 132
                self.match(IEC61131ParserParser.PROGRAM)
                self.state = 133
                self.match(IEC61131ParserParser.IDENTIFIER)
                self.state = 135
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & ((1 << (IEC61131ParserParser.VAR_EXTERNAL - 68)) | (1 << (IEC61131ParserParser.VAR_GLOBAL - 68)) | (1 << (IEC61131ParserParser.VAR_OUTPUT - 68)) | (1 << (IEC61131ParserParser.VAR_IN_OUT - 68)) | (1 << (IEC61131ParserParser.VAR_INPUT - 68)))) != 0) or _la==IEC61131ParserParser.VAR:
                    self.state = 134
                    self.variable_blocks()


                self.state = 138
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << IEC61131ParserParser.T__8) | (1 << IEC61131ParserParser.T__9) | (1 << IEC61131ParserParser.UDINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UDINT) | (1 << IEC61131ParserParser.DINT_TO_UDINT) | (1 << IEC61131ParserParser.UDINT_TO_DINT) | (1 << IEC61131ParserParser.UINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_BYTE) | (1 << IEC61131ParserParser.BYTE_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UINT) | (1 << IEC61131ParserParser.USINT_TO_DINT) | (1 << IEC61131ParserParser.DINT_TO_USINT) | (1 << IEC61131ParserParser.BYTE_TO_WORD) | (1 << IEC61131ParserParser.BYTE_TO_UINT) | (1 << IEC61131ParserParser.WORD_TO_BYTE) | (1 << IEC61131ParserParser.WORD_TO_UINT) | (1 << IEC61131ParserParser.REAL_TO_UINT) | (1 << IEC61131ParserParser.INT_TO_USINT) | (1 << IEC61131ParserParser.UINT_TO_BOOL) | (1 << IEC61131ParserParser.UINT_TO_WORD) | (1 << IEC61131ParserParser.UINT_TO_REAL) | (1 << IEC61131ParserParser.DINT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_DINT) | (1 << IEC61131ParserParser.WORD_TO_INT) | (1 << IEC61131ParserParser.REAL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_BOOL) | (1 << IEC61131ParserParser.BOOL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_WORD) | (1 << IEC61131ParserParser.INT_TO_REAL) | (1 << IEC61131ParserParser.INT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_INT))) != 0) or ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & ((1 << (IEC61131ParserParser.REPLACE - 116)) | (1 << (IEC61131ParserParser.REPEAT - 116)) | (1 << (IEC61131ParserParser.INSERT - 116)) | (1 << (IEC61131ParserParser.DELETE - 116)) | (1 << (IEC61131ParserParser.CONCAT - 116)) | (1 << (IEC61131ParserParser.CALCN - 116)) | (1 << (IEC61131ParserParser.RETCN - 116)) | (1 << (IEC61131ParserParser.JMPCN - 116)) | (1 << (IEC61131ParserParser.WHILE - 116)) | (1 << (IEC61131ParserParser.RIGHT - 116)) | (1 << (IEC61131ParserParser.LIMIT - 116)) | (1 << (IEC61131ParserParser.TRUNC - 116)) | (1 << (IEC61131ParserParser.ATAN2 - 116)) | (1 << (IEC61131ParserParser.CASE - 116)) | (1 << (IEC61131ParserParser.CALC - 116)))) != 0) or ((((_la - 184)) & ~0x3f) == 0 and ((1 << (_la - 184)) & ((1 << (IEC61131ParserParser.ANDN - 184)) | (1 << (IEC61131ParserParser.XORN - 184)) | (1 << (IEC61131ParserParser.RETC - 184)) | (1 << (IEC61131ParserParser.JMPC - 184)) | (1 << (IEC61131ParserParser.SQRT - 184)) | (1 << (IEC61131ParserParser.ASIN - 184)) | (1 << (IEC61131ParserParser.ACOS - 184)) | (1 << (IEC61131ParserParser.ATAN - 184)) | (1 << (IEC61131ParserParser.EXPT - 184)) | (1 << (IEC61131ParserParser.MOVE - 184)) | (1 << (IEC61131ParserParser.LEFT - 184)) | (1 << (IEC61131ParserParser.FIND - 184)) | (1 << (IEC61131ParserParser.FOR - 184)) | (1 << (IEC61131ParserParser.NOT - 184)) | (1 << (IEC61131ParserParser.MUL - 184)) | (1 << (IEC61131ParserParser.ADD - 184)) | (1 << (IEC61131ParserParser.CAL - 184)) | (1 << (IEC61131ParserParser.STN - 184)) | (1 << (IEC61131ParserParser.LDN - 184)) | (1 << (IEC61131ParserParser.AND - 184)) | (1 << (IEC61131ParserParser.XOR - 184)) | (1 << (IEC61131ParserParser.ORN - 184)) | (1 << (IEC61131ParserParser.SUB - 184)) | (1 << (IEC61131ParserParser.MOD - 184)) | (1 << (IEC61131ParserParser.DIV - 184)) | (1 << (IEC61131ParserParser.RET - 184)) | (1 << (IEC61131ParserParser.JMP - 184)) | (1 << (IEC61131ParserParser.ABS - 184)) | (1 << (IEC61131ParserParser.LOG - 184)) | (1 << (IEC61131ParserParser.EXP - 184)) | (1 << (IEC61131ParserParser.SIN - 184)) | (1 << (IEC61131ParserParser.COS - 184)) | (1 << (IEC61131ParserParser.TAN - 184)) | (1 << (IEC61131ParserParser.SHL - 184)) | (1 << (IEC61131ParserParser.SHR - 184)) | (1 << (IEC61131ParserParser.ROL - 184)) | (1 << (IEC61131ParserParser.ROR - 184)) | (1 << (IEC61131ParserParser.SEL - 184)) | (1 << (IEC61131ParserParser.MAX - 184)) | (1 << (IEC61131ParserParser.MIN - 184)) | (1 << (IEC61131ParserParser.MUX - 184)) | (1 << (IEC61131ParserParser.LEN - 184)) | (1 << (IEC61131ParserParser.MID - 184)))) != 0) or ((((_la - 255)) & ~0x3f) == 0 and ((1 << (_la - 255)) & ((1 << (IEC61131ParserParser.LD - 255)) | (1 << (IEC61131ParserParser.ST - 255)) | (1 << (IEC61131ParserParser.OR - 255)) | (1 << (IEC61131ParserParser.GT - 255)) | (1 << (IEC61131ParserParser.GE - 255)) | (1 << (IEC61131ParserParser.EQ - 255)) | (1 << (IEC61131ParserParser.LT - 255)) | (1 << (IEC61131ParserParser.LE - 255)) | (1 << (IEC61131ParserParser.NE - 255)) | (1 << (IEC61131ParserParser.IF - 255)) | (1 << (IEC61131ParserParser.LN - 255)) | (1 << (IEC61131ParserParser.IDENTIFIER - 255)))) != 0):
                    self.state = 137
                    self.body()


                self.state = 140
                self.match(IEC61131ParserParser.END_PROGRAM)
                pass
            elif token in [IEC61131ParserParser.FUNCTION_BLOCK]:
                localctx = IEC61131ParserParser.FbDeclContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 141
                self.match(IEC61131ParserParser.FUNCTION_BLOCK)
                self.state = 144
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [IEC61131ParserParser.IDENTIFIER]:
                    self.state = 142
                    self.match(IEC61131ParserParser.IDENTIFIER)
                    pass
                elif token in [IEC61131ParserParser.R_TRIG, IEC61131ParserParser.F_TRIG, IEC61131ParserParser.CTU, IEC61131ParserParser.TON, IEC61131ParserParser.TOF, IEC61131ParserParser.TP]:
                    self.state = 143
                    self.fb_std_names()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 147
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & ((1 << (IEC61131ParserParser.VAR_EXTERNAL - 68)) | (1 << (IEC61131ParserParser.VAR_GLOBAL - 68)) | (1 << (IEC61131ParserParser.VAR_OUTPUT - 68)) | (1 << (IEC61131ParserParser.VAR_IN_OUT - 68)) | (1 << (IEC61131ParserParser.VAR_INPUT - 68)))) != 0) or _la==IEC61131ParserParser.VAR:
                    self.state = 146
                    self.variable_blocks()


                self.state = 150
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << IEC61131ParserParser.T__8) | (1 << IEC61131ParserParser.T__9) | (1 << IEC61131ParserParser.UDINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UDINT) | (1 << IEC61131ParserParser.DINT_TO_UDINT) | (1 << IEC61131ParserParser.UDINT_TO_DINT) | (1 << IEC61131ParserParser.UINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_BYTE) | (1 << IEC61131ParserParser.BYTE_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UINT) | (1 << IEC61131ParserParser.USINT_TO_DINT) | (1 << IEC61131ParserParser.DINT_TO_USINT) | (1 << IEC61131ParserParser.BYTE_TO_WORD) | (1 << IEC61131ParserParser.BYTE_TO_UINT) | (1 << IEC61131ParserParser.WORD_TO_BYTE) | (1 << IEC61131ParserParser.WORD_TO_UINT) | (1 << IEC61131ParserParser.REAL_TO_UINT) | (1 << IEC61131ParserParser.INT_TO_USINT) | (1 << IEC61131ParserParser.UINT_TO_BOOL) | (1 << IEC61131ParserParser.UINT_TO_WORD) | (1 << IEC61131ParserParser.UINT_TO_REAL) | (1 << IEC61131ParserParser.DINT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_DINT) | (1 << IEC61131ParserParser.WORD_TO_INT) | (1 << IEC61131ParserParser.REAL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_BOOL) | (1 << IEC61131ParserParser.BOOL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_WORD) | (1 << IEC61131ParserParser.INT_TO_REAL) | (1 << IEC61131ParserParser.INT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_INT))) != 0) or ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & ((1 << (IEC61131ParserParser.REPLACE - 116)) | (1 << (IEC61131ParserParser.REPEAT - 116)) | (1 << (IEC61131ParserParser.INSERT - 116)) | (1 << (IEC61131ParserParser.DELETE - 116)) | (1 << (IEC61131ParserParser.CONCAT - 116)) | (1 << (IEC61131ParserParser.CALCN - 116)) | (1 << (IEC61131ParserParser.RETCN - 116)) | (1 << (IEC61131ParserParser.JMPCN - 116)) | (1 << (IEC61131ParserParser.WHILE - 116)) | (1 << (IEC61131ParserParser.RIGHT - 116)) | (1 << (IEC61131ParserParser.LIMIT - 116)) | (1 << (IEC61131ParserParser.TRUNC - 116)) | (1 << (IEC61131ParserParser.ATAN2 - 116)) | (1 << (IEC61131ParserParser.CASE - 116)) | (1 << (IEC61131ParserParser.CALC - 116)))) != 0) or ((((_la - 184)) & ~0x3f) == 0 and ((1 << (_la - 184)) & ((1 << (IEC61131ParserParser.ANDN - 184)) | (1 << (IEC61131ParserParser.XORN - 184)) | (1 << (IEC61131ParserParser.RETC - 184)) | (1 << (IEC61131ParserParser.JMPC - 184)) | (1 << (IEC61131ParserParser.SQRT - 184)) | (1 << (IEC61131ParserParser.ASIN - 184)) | (1 << (IEC61131ParserParser.ACOS - 184)) | (1 << (IEC61131ParserParser.ATAN - 184)) | (1 << (IEC61131ParserParser.EXPT - 184)) | (1 << (IEC61131ParserParser.MOVE - 184)) | (1 << (IEC61131ParserParser.LEFT - 184)) | (1 << (IEC61131ParserParser.FIND - 184)) | (1 << (IEC61131ParserParser.FOR - 184)) | (1 << (IEC61131ParserParser.NOT - 184)) | (1 << (IEC61131ParserParser.MUL - 184)) | (1 << (IEC61131ParserParser.ADD - 184)) | (1 << (IEC61131ParserParser.CAL - 184)) | (1 << (IEC61131ParserParser.STN - 184)) | (1 << (IEC61131ParserParser.LDN - 184)) | (1 << (IEC61131ParserParser.AND - 184)) | (1 << (IEC61131ParserParser.XOR - 184)) | (1 << (IEC61131ParserParser.ORN - 184)) | (1 << (IEC61131ParserParser.SUB - 184)) | (1 << (IEC61131ParserParser.MOD - 184)) | (1 << (IEC61131ParserParser.DIV - 184)) | (1 << (IEC61131ParserParser.RET - 184)) | (1 << (IEC61131ParserParser.JMP - 184)) | (1 << (IEC61131ParserParser.ABS - 184)) | (1 << (IEC61131ParserParser.LOG - 184)) | (1 << (IEC61131ParserParser.EXP - 184)) | (1 << (IEC61131ParserParser.SIN - 184)) | (1 << (IEC61131ParserParser.COS - 184)) | (1 << (IEC61131ParserParser.TAN - 184)) | (1 << (IEC61131ParserParser.SHL - 184)) | (1 << (IEC61131ParserParser.SHR - 184)) | (1 << (IEC61131ParserParser.ROL - 184)) | (1 << (IEC61131ParserParser.ROR - 184)) | (1 << (IEC61131ParserParser.SEL - 184)) | (1 << (IEC61131ParserParser.MAX - 184)) | (1 << (IEC61131ParserParser.MIN - 184)) | (1 << (IEC61131ParserParser.MUX - 184)) | (1 << (IEC61131ParserParser.LEN - 184)) | (1 << (IEC61131ParserParser.MID - 184)))) != 0) or ((((_la - 255)) & ~0x3f) == 0 and ((1 << (_la - 255)) & ((1 << (IEC61131ParserParser.LD - 255)) | (1 << (IEC61131ParserParser.ST - 255)) | (1 << (IEC61131ParserParser.OR - 255)) | (1 << (IEC61131ParserParser.GT - 255)) | (1 << (IEC61131ParserParser.GE - 255)) | (1 << (IEC61131ParserParser.EQ - 255)) | (1 << (IEC61131ParserParser.LT - 255)) | (1 << (IEC61131ParserParser.LE - 255)) | (1 << (IEC61131ParserParser.NE - 255)) | (1 << (IEC61131ParserParser.IF - 255)) | (1 << (IEC61131ParserParser.LN - 255)) | (1 << (IEC61131ParserParser.IDENTIFIER - 255)))) != 0):
                    self.state = 149
                    self.body()


                self.state = 152
                self.match(IEC61131ParserParser.END_FUNCTION_BLOCK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fb_std_namesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def R_TRIG(self):
            return self.getToken(IEC61131ParserParser.R_TRIG, 0)

        def F_TRIG(self):
            return self.getToken(IEC61131ParserParser.F_TRIG, 0)

        def TON(self):
            return self.getToken(IEC61131ParserParser.TON, 0)

        def TOF(self):
            return self.getToken(IEC61131ParserParser.TOF, 0)

        def TP(self):
            return self.getToken(IEC61131ParserParser.TP, 0)

        def CTU(self):
            return self.getToken(IEC61131ParserParser.CTU, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_fb_std_names

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFb_std_names" ):
                return visitor.visitFb_std_names(self)
            else:
                return visitor.visitChildren(self)




    def fb_std_names(self):

        localctx = IEC61131ParserParser.Fb_std_namesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_fb_std_names)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            _la = self._input.LA(1)
            if not(_la==IEC61131ParserParser.R_TRIG or _la==IEC61131ParserParser.F_TRIG or ((((_la - 220)) & ~0x3f) == 0 and ((1 << (_la - 220)) & ((1 << (IEC61131ParserParser.CTU - 220)) | (1 << (IEC61131ParserParser.TON - 220)) | (1 << (IEC61131ParserParser.TOF - 220)) | (1 << (IEC61131ParserParser.TP - 220)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_body

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BodyILContext(BodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.BodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def instruction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.InstructionContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.InstructionContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBodyIL" ):
                return visitor.visitBodyIL(self)
            else:
                return visitor.visitChildren(self)


    class BodySTContext(BodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.BodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def stmt_block(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Stmt_blockContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBodyST" ):
                return visitor.visitBodyST(self)
            else:
                return visitor.visitChildren(self)



    def body(self):

        localctx = IEC61131ParserParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_body)
        self._la = 0 # Token type
        try:
            self.state = 163
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                localctx = IEC61131ParserParser.BodyILContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 158 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 157
                    self.instruction()
                    self.state = 160 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << IEC61131ParserParser.T__8) | (1 << IEC61131ParserParser.T__9) | (1 << IEC61131ParserParser.UDINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UDINT) | (1 << IEC61131ParserParser.DINT_TO_UDINT) | (1 << IEC61131ParserParser.UDINT_TO_DINT) | (1 << IEC61131ParserParser.UINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_BYTE) | (1 << IEC61131ParserParser.BYTE_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UINT) | (1 << IEC61131ParserParser.USINT_TO_DINT) | (1 << IEC61131ParserParser.DINT_TO_USINT) | (1 << IEC61131ParserParser.BYTE_TO_WORD) | (1 << IEC61131ParserParser.BYTE_TO_UINT) | (1 << IEC61131ParserParser.WORD_TO_BYTE) | (1 << IEC61131ParserParser.WORD_TO_UINT) | (1 << IEC61131ParserParser.REAL_TO_UINT) | (1 << IEC61131ParserParser.INT_TO_USINT) | (1 << IEC61131ParserParser.UINT_TO_BOOL) | (1 << IEC61131ParserParser.UINT_TO_WORD) | (1 << IEC61131ParserParser.UINT_TO_REAL) | (1 << IEC61131ParserParser.DINT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_DINT) | (1 << IEC61131ParserParser.WORD_TO_INT) | (1 << IEC61131ParserParser.REAL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_BOOL) | (1 << IEC61131ParserParser.BOOL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_WORD) | (1 << IEC61131ParserParser.INT_TO_REAL) | (1 << IEC61131ParserParser.INT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_INT))) != 0) or ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & ((1 << (IEC61131ParserParser.REPLACE - 116)) | (1 << (IEC61131ParserParser.INSERT - 116)) | (1 << (IEC61131ParserParser.DELETE - 116)) | (1 << (IEC61131ParserParser.CONCAT - 116)) | (1 << (IEC61131ParserParser.CALCN - 116)) | (1 << (IEC61131ParserParser.RETCN - 116)) | (1 << (IEC61131ParserParser.JMPCN - 116)) | (1 << (IEC61131ParserParser.RIGHT - 116)) | (1 << (IEC61131ParserParser.LIMIT - 116)) | (1 << (IEC61131ParserParser.TRUNC - 116)) | (1 << (IEC61131ParserParser.ATAN2 - 116)) | (1 << (IEC61131ParserParser.CALC - 116)))) != 0) or ((((_la - 184)) & ~0x3f) == 0 and ((1 << (_la - 184)) & ((1 << (IEC61131ParserParser.ANDN - 184)) | (1 << (IEC61131ParserParser.XORN - 184)) | (1 << (IEC61131ParserParser.RETC - 184)) | (1 << (IEC61131ParserParser.JMPC - 184)) | (1 << (IEC61131ParserParser.SQRT - 184)) | (1 << (IEC61131ParserParser.ASIN - 184)) | (1 << (IEC61131ParserParser.ACOS - 184)) | (1 << (IEC61131ParserParser.ATAN - 184)) | (1 << (IEC61131ParserParser.EXPT - 184)) | (1 << (IEC61131ParserParser.MOVE - 184)) | (1 << (IEC61131ParserParser.LEFT - 184)) | (1 << (IEC61131ParserParser.FIND - 184)) | (1 << (IEC61131ParserParser.NOT - 184)) | (1 << (IEC61131ParserParser.MUL - 184)) | (1 << (IEC61131ParserParser.ADD - 184)) | (1 << (IEC61131ParserParser.CAL - 184)) | (1 << (IEC61131ParserParser.STN - 184)) | (1 << (IEC61131ParserParser.LDN - 184)) | (1 << (IEC61131ParserParser.AND - 184)) | (1 << (IEC61131ParserParser.XOR - 184)) | (1 << (IEC61131ParserParser.ORN - 184)) | (1 << (IEC61131ParserParser.SUB - 184)) | (1 << (IEC61131ParserParser.MOD - 184)) | (1 << (IEC61131ParserParser.DIV - 184)) | (1 << (IEC61131ParserParser.RET - 184)) | (1 << (IEC61131ParserParser.JMP - 184)) | (1 << (IEC61131ParserParser.ABS - 184)) | (1 << (IEC61131ParserParser.LOG - 184)) | (1 << (IEC61131ParserParser.EXP - 184)) | (1 << (IEC61131ParserParser.SIN - 184)) | (1 << (IEC61131ParserParser.COS - 184)) | (1 << (IEC61131ParserParser.TAN - 184)) | (1 << (IEC61131ParserParser.SHL - 184)) | (1 << (IEC61131ParserParser.SHR - 184)) | (1 << (IEC61131ParserParser.ROL - 184)) | (1 << (IEC61131ParserParser.ROR - 184)) | (1 << (IEC61131ParserParser.SEL - 184)) | (1 << (IEC61131ParserParser.MAX - 184)) | (1 << (IEC61131ParserParser.MIN - 184)) | (1 << (IEC61131ParserParser.MUX - 184)) | (1 << (IEC61131ParserParser.LEN - 184)) | (1 << (IEC61131ParserParser.MID - 184)))) != 0) or ((((_la - 255)) & ~0x3f) == 0 and ((1 << (_la - 255)) & ((1 << (IEC61131ParserParser.LD - 255)) | (1 << (IEC61131ParserParser.ST - 255)) | (1 << (IEC61131ParserParser.OR - 255)) | (1 << (IEC61131ParserParser.GT - 255)) | (1 << (IEC61131ParserParser.GE - 255)) | (1 << (IEC61131ParserParser.EQ - 255)) | (1 << (IEC61131ParserParser.LT - 255)) | (1 << (IEC61131ParserParser.LE - 255)) | (1 << (IEC61131ParserParser.NE - 255)) | (1 << (IEC61131ParserParser.LN - 255)) | (1 << (IEC61131ParserParser.IDENTIFIER - 255)))) != 0)):
                        break

                pass

            elif la_ == 2:
                localctx = IEC61131ParserParser.BodySTContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 162
                self.stmt_block()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_blocksContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_block(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Variable_blockContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Variable_blockContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_variable_blocks

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_blocks" ):
                return visitor.visitVariable_blocks(self)
            else:
                return visitor.visitChildren(self)




    def variable_blocks(self):

        localctx = IEC61131ParserParser.Variable_blocksContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_variable_blocks)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 165
                self.variable_block()
                self.state = 168 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & ((1 << (IEC61131ParserParser.VAR_EXTERNAL - 68)) | (1 << (IEC61131ParserParser.VAR_GLOBAL - 68)) | (1 << (IEC61131ParserParser.VAR_OUTPUT - 68)) | (1 << (IEC61131ParserParser.VAR_IN_OUT - 68)) | (1 << (IEC61131ParserParser.VAR_INPUT - 68)))) != 0) or _la==IEC61131ParserParser.VAR):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_blockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_variable_block

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class VarOutputBlockContext(Variable_blockContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Variable_blockContext
            super().__init__(parser)
            self.attr = None # Token
            self.copyFrom(ctx)

        def VAR_OUTPUT(self):
            return self.getToken(IEC61131ParserParser.VAR_OUTPUT, 0)
        def variable_decls(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_declsContext,0)

        def END_VAR(self):
            return self.getToken(IEC61131ParserParser.END_VAR, 0)
        def RETAIN(self):
            return self.getToken(IEC61131ParserParser.RETAIN, 0)
        def NON_RETAIN(self):
            return self.getToken(IEC61131ParserParser.NON_RETAIN, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarOutputBlock" ):
                return visitor.visitVarOutputBlock(self)
            else:
                return visitor.visitChildren(self)


    class VarExternalBlockContext(Variable_blockContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Variable_blockContext
            super().__init__(parser)
            self.attr = None # Token
            self.copyFrom(ctx)

        def VAR_EXTERNAL(self):
            return self.getToken(IEC61131ParserParser.VAR_EXTERNAL, 0)
        def variable_decls(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_declsContext,0)

        def END_VAR(self):
            return self.getToken(IEC61131ParserParser.END_VAR, 0)
        def CONSTANT(self):
            return self.getToken(IEC61131ParserParser.CONSTANT, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarExternalBlock" ):
                return visitor.visitVarExternalBlock(self)
            else:
                return visitor.visitChildren(self)


    class VarGlobalBlockContext(Variable_blockContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Variable_blockContext
            super().__init__(parser)
            self.attr = None # Token
            self.copyFrom(ctx)

        def VAR_GLOBAL(self):
            return self.getToken(IEC61131ParserParser.VAR_GLOBAL, 0)
        def variable_decls(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_declsContext,0)

        def END_VAR(self):
            return self.getToken(IEC61131ParserParser.END_VAR, 0)
        def CONSTANT(self):
            return self.getToken(IEC61131ParserParser.CONSTANT, 0)
        def RETAIN(self):
            return self.getToken(IEC61131ParserParser.RETAIN, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarGlobalBlock" ):
                return visitor.visitVarGlobalBlock(self)
            else:
                return visitor.visitChildren(self)


    class VarInputBlockContext(Variable_blockContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Variable_blockContext
            super().__init__(parser)
            self.attr = None # Token
            self.copyFrom(ctx)

        def VAR_INPUT(self):
            return self.getToken(IEC61131ParserParser.VAR_INPUT, 0)
        def variable_decls(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_declsContext,0)

        def END_VAR(self):
            return self.getToken(IEC61131ParserParser.END_VAR, 0)
        def RETAIN(self):
            return self.getToken(IEC61131ParserParser.RETAIN, 0)
        def NON_RETAIN(self):
            return self.getToken(IEC61131ParserParser.NON_RETAIN, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarInputBlock" ):
                return visitor.visitVarInputBlock(self)
            else:
                return visitor.visitChildren(self)


    class VarInOutBlockContext(Variable_blockContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Variable_blockContext
            super().__init__(parser)
            self.attr = None # Token
            self.copyFrom(ctx)

        def VAR_IN_OUT(self):
            return self.getToken(IEC61131ParserParser.VAR_IN_OUT, 0)
        def variable_decls(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_declsContext,0)

        def END_VAR(self):
            return self.getToken(IEC61131ParserParser.END_VAR, 0)
        def RETAIN(self):
            return self.getToken(IEC61131ParserParser.RETAIN, 0)
        def NON_RETAIN(self):
            return self.getToken(IEC61131ParserParser.NON_RETAIN, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarInOutBlock" ):
                return visitor.visitVarInOutBlock(self)
            else:
                return visitor.visitChildren(self)


    class VarLocalBlockContext(Variable_blockContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Variable_blockContext
            super().__init__(parser)
            self.attr = None # Token
            self.copyFrom(ctx)

        def VAR(self):
            return self.getToken(IEC61131ParserParser.VAR, 0)
        def variable_decls(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_declsContext,0)

        def END_VAR(self):
            return self.getToken(IEC61131ParserParser.END_VAR, 0)
        def CONSTANT(self):
            return self.getToken(IEC61131ParserParser.CONSTANT, 0)
        def RETAIN(self):
            return self.getToken(IEC61131ParserParser.RETAIN, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarLocalBlock" ):
                return visitor.visitVarLocalBlock(self)
            else:
                return visitor.visitChildren(self)



    def variable_block(self):

        localctx = IEC61131ParserParser.Variable_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_variable_block)
        self._la = 0 # Token type
        try:
            self.state = 212
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IEC61131ParserParser.VAR_GLOBAL]:
                localctx = IEC61131ParserParser.VarGlobalBlockContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 170
                self.match(IEC61131ParserParser.VAR_GLOBAL)
                self.state = 172
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.CONSTANT or _la==IEC61131ParserParser.RETAIN:
                    self.state = 171
                    localctx.attr = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==IEC61131ParserParser.CONSTANT or _la==IEC61131ParserParser.RETAIN):
                        localctx.attr = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 174
                self.variable_decls()
                self.state = 175
                self.match(IEC61131ParserParser.END_VAR)
                pass
            elif token in [IEC61131ParserParser.VAR]:
                localctx = IEC61131ParserParser.VarLocalBlockContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 177
                self.match(IEC61131ParserParser.VAR)
                self.state = 179
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.CONSTANT or _la==IEC61131ParserParser.RETAIN:
                    self.state = 178
                    localctx.attr = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==IEC61131ParserParser.CONSTANT or _la==IEC61131ParserParser.RETAIN):
                        localctx.attr = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 181
                self.variable_decls()
                self.state = 182
                self.match(IEC61131ParserParser.END_VAR)
                pass
            elif token in [IEC61131ParserParser.VAR_INPUT]:
                localctx = IEC61131ParserParser.VarInputBlockContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 184
                self.match(IEC61131ParserParser.VAR_INPUT)
                self.state = 186
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.NON_RETAIN or _la==IEC61131ParserParser.RETAIN:
                    self.state = 185
                    localctx.attr = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==IEC61131ParserParser.NON_RETAIN or _la==IEC61131ParserParser.RETAIN):
                        localctx.attr = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 188
                self.variable_decls()
                self.state = 189
                self.match(IEC61131ParserParser.END_VAR)
                pass
            elif token in [IEC61131ParserParser.VAR_OUTPUT]:
                localctx = IEC61131ParserParser.VarOutputBlockContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 191
                self.match(IEC61131ParserParser.VAR_OUTPUT)
                self.state = 193
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.NON_RETAIN or _la==IEC61131ParserParser.RETAIN:
                    self.state = 192
                    localctx.attr = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==IEC61131ParserParser.NON_RETAIN or _la==IEC61131ParserParser.RETAIN):
                        localctx.attr = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 195
                self.variable_decls()
                self.state = 196
                self.match(IEC61131ParserParser.END_VAR)
                pass
            elif token in [IEC61131ParserParser.VAR_IN_OUT]:
                localctx = IEC61131ParserParser.VarInOutBlockContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 198
                self.match(IEC61131ParserParser.VAR_IN_OUT)
                self.state = 200
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.NON_RETAIN or _la==IEC61131ParserParser.RETAIN:
                    self.state = 199
                    localctx.attr = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==IEC61131ParserParser.NON_RETAIN or _la==IEC61131ParserParser.RETAIN):
                        localctx.attr = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 202
                self.variable_decls()
                self.state = 203
                self.match(IEC61131ParserParser.END_VAR)
                pass
            elif token in [IEC61131ParserParser.VAR_EXTERNAL]:
                localctx = IEC61131ParserParser.VarExternalBlockContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 205
                self.match(IEC61131ParserParser.VAR_EXTERNAL)
                self.state = 207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.CONSTANT:
                    self.state = 206
                    localctx.attr = self.match(IEC61131ParserParser.CONSTANT)


                self.state = 209
                self.variable_decls()
                self.state = 210
                self.match(IEC61131ParserParser.END_VAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_declsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Variable_declContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Variable_declContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_variable_decls

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_decls" ):
                return visitor.visitVariable_decls(self)
            else:
                return visitor.visitChildren(self)




    def variable_decls(self):

        localctx = IEC61131ParserParser.Variable_declsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_variable_decls)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==IEC61131ParserParser.T__1 or _la==IEC61131ParserParser.AT or _la==IEC61131ParserParser.IDENTIFIER:
                self.state = 214
                self.variable_decl()
                self.state = 215
                self.match(IEC61131ParserParser.T__0)
                self.state = 221
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_variable_decl

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class VarDeclInitContext(Variable_declContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Variable_declContext
            super().__init__(parser)
            self.name = None # Variable_nameContext
            self.loc = None # Located_atContext
            self.dt = None # Data_typeContext
            self.init = None # Variable_initContext
            self.copyFrom(ctx)

        def data_type(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Data_typeContext,0)

        def variable_init(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_initContext,0)

        def variable_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_nameContext,0)

        def located_at(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Located_atContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclInit" ):
                return visitor.visitVarDeclInit(self)
            else:
                return visitor.visitChildren(self)


    class VarDeclRevLocContext(Variable_declContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Variable_declContext
            super().__init__(parser)
            self.name = None # Variable_nameContext
            self.dt = None # Data_typeContext
            self.loc = None # Located_atContext
            self.copyFrom(ctx)

        def data_type(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Data_typeContext,0)

        def located_at(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Located_atContext,0)

        def variable_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_nameContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclRevLoc" ):
                return visitor.visitVarDeclRevLoc(self)
            else:
                return visitor.visitChildren(self)


    class VarDeclNoInitContext(Variable_declContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Variable_declContext
            super().__init__(parser)
            self.name = None # Variable_nameContext
            self.loc = None # Located_atContext
            self.dt = None # Data_typeContext
            self.copyFrom(ctx)

        def data_type(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Data_typeContext,0)

        def variable_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_nameContext,0)

        def located_at(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Located_atContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclNoInit" ):
                return visitor.visitVarDeclNoInit(self)
            else:
                return visitor.visitChildren(self)



    def variable_decl(self):

        localctx = IEC61131ParserParser.Variable_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_variable_decl)
        self._la = 0 # Token type
        try:
            self.state = 248
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                localctx = IEC61131ParserParser.VarDeclInitContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 223
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.IDENTIFIER:
                    self.state = 222
                    localctx.name = self.variable_name()


                self.state = 226
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.AT:
                    self.state = 225
                    localctx.loc = self.located_at()


                self.state = 228
                self.match(IEC61131ParserParser.T__1)
                self.state = 229
                localctx.dt = self.data_type()
                self.state = 230
                self.match(IEC61131ParserParser.T__2)
                self.state = 231
                localctx.init = self.variable_init()
                pass

            elif la_ == 2:
                localctx = IEC61131ParserParser.VarDeclNoInitContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 234
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.IDENTIFIER:
                    self.state = 233
                    localctx.name = self.variable_name()


                self.state = 237
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.AT:
                    self.state = 236
                    localctx.loc = self.located_at()


                self.state = 239
                self.match(IEC61131ParserParser.T__1)
                self.state = 240
                localctx.dt = self.data_type()
                pass

            elif la_ == 3:
                localctx = IEC61131ParserParser.VarDeclRevLocContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 242
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.IDENTIFIER:
                    self.state = 241
                    localctx.name = self.variable_name()


                self.state = 244
                self.match(IEC61131ParserParser.T__1)
                self.state = 245
                localctx.dt = self.data_type()
                self.state = 246
                localctx.loc = self.located_at()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Located_atContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(IEC61131ParserParser.AT, 0)

        def DIRECTVARIABLE(self):
            return self.getToken(IEC61131ParserParser.DIRECTVARIABLE, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_located_at

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocated_at" ):
                return visitor.visitLocated_at(self)
            else:
                return visitor.visitChildren(self)




    def located_at(self):

        localctx = IEC61131ParserParser.Located_atContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_located_at)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(IEC61131ParserParser.AT)
            self.state = 251
            self.match(IEC61131ParserParser.DIRECTVARIABLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_initContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signed_int(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Signed_intContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_variable_init

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_init" ):
                return visitor.visitVariable_init(self)
            else:
                return visitor.visitChildren(self)




    def variable_init(self):

        localctx = IEC61131ParserParser.Variable_initContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_variable_init)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self.signed_int()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_data_type

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class StdFbDataTypeContext(Data_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Data_typeContext
            super().__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def SR(self):
            return self.getToken(IEC61131ParserParser.SR, 0)
        def RS(self):
            return self.getToken(IEC61131ParserParser.RS, 0)
        def R_TRIG(self):
            return self.getToken(IEC61131ParserParser.R_TRIG, 0)
        def F_TRIG(self):
            return self.getToken(IEC61131ParserParser.F_TRIG, 0)
        def CTU(self):
            return self.getToken(IEC61131ParserParser.CTU, 0)
        def CTD(self):
            return self.getToken(IEC61131ParserParser.CTD, 0)
        def CTUD(self):
            return self.getToken(IEC61131ParserParser.CTUD, 0)
        def TP(self):
            return self.getToken(IEC61131ParserParser.TP, 0)
        def TON(self):
            return self.getToken(IEC61131ParserParser.TON, 0)
        def TOF(self):
            return self.getToken(IEC61131ParserParser.TOF, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStdFbDataType" ):
                return visitor.visitStdFbDataType(self)
            else:
                return visitor.visitChildren(self)


    class BasicDataTypeContext(Data_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Data_typeContext
            super().__init__(parser)
            self.name = None # Token
            self.attr = None # Token
            self.copyFrom(ctx)

        def BOOL(self):
            return self.getToken(IEC61131ParserParser.BOOL, 0)
        def BYTE(self):
            return self.getToken(IEC61131ParserParser.BYTE, 0)
        def WORD(self):
            return self.getToken(IEC61131ParserParser.WORD, 0)
        def DWORD(self):
            return self.getToken(IEC61131ParserParser.DWORD, 0)
        def INT(self):
            return self.getToken(IEC61131ParserParser.INT, 0)
        def SINT(self):
            return self.getToken(IEC61131ParserParser.SINT, 0)
        def DINT(self):
            return self.getToken(IEC61131ParserParser.DINT, 0)
        def UINT(self):
            return self.getToken(IEC61131ParserParser.UINT, 0)
        def USINT(self):
            return self.getToken(IEC61131ParserParser.USINT, 0)
        def UDINT(self):
            return self.getToken(IEC61131ParserParser.UDINT, 0)
        def REAL(self):
            return self.getToken(IEC61131ParserParser.REAL, 0)
        def BOOL_EXP(self):
            return self.getToken(IEC61131ParserParser.BOOL_EXP, 0)
        def R_EDGE(self):
            return self.getToken(IEC61131ParserParser.R_EDGE, 0)
        def F_EDGE(self):
            return self.getToken(IEC61131ParserParser.F_EDGE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasicDataType" ):
                return visitor.visitBasicDataType(self)
            else:
                return visitor.visitChildren(self)


    class TimeDataTypeContext(Data_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Data_typeContext
            super().__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def TIME(self):
            return self.getToken(IEC61131ParserParser.TIME, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeDataType" ):
                return visitor.visitTimeDataType(self)
            else:
                return visitor.visitChildren(self)


    class ArrayDataTypeContext(Data_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Data_typeContext
            super().__init__(parser)
            self.name = None # Token
            self.ranfrom = None # Uns_intContext
            self.ranto = None # Uns_intContext
            self.dt = None # Data_typeContext
            self.copyFrom(ctx)

        def OF(self):
            return self.getToken(IEC61131ParserParser.OF, 0)
        def ARRAY(self):
            return self.getToken(IEC61131ParserParser.ARRAY, 0)
        def uns_int(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Uns_intContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Uns_intContext,i)

        def data_type(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Data_typeContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayDataType" ):
                return visitor.visitArrayDataType(self)
            else:
                return visitor.visitChildren(self)


    class UsrFbDataTypeContext(Data_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Data_typeContext
            super().__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(IEC61131ParserParser.IDENTIFIER, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUsrFbDataType" ):
                return visitor.visitUsrFbDataType(self)
            else:
                return visitor.visitChildren(self)



    def data_type(self):

        localctx = IEC61131ParserParser.Data_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_data_type)
        self._la = 0 # Token type
        try:
            self.state = 271
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IEC61131ParserParser.BOOL_EXP, IEC61131ParserParser.DWORD, IEC61131ParserParser.USINT, IEC61131ParserParser.UDINT, IEC61131ParserParser.REAL, IEC61131ParserParser.BYTE, IEC61131ParserParser.WORD, IEC61131ParserParser.BOOL, IEC61131ParserParser.UINT, IEC61131ParserParser.SINT, IEC61131ParserParser.DINT, IEC61131ParserParser.INT]:
                localctx = IEC61131ParserParser.BasicDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 255
                localctx.name = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 101)) & ~0x3f) == 0 and ((1 << (_la - 101)) & ((1 << (IEC61131ParserParser.BOOL_EXP - 101)) | (1 << (IEC61131ParserParser.DWORD - 101)) | (1 << (IEC61131ParserParser.USINT - 101)) | (1 << (IEC61131ParserParser.UDINT - 101)))) != 0) or ((((_la - 165)) & ~0x3f) == 0 and ((1 << (_la - 165)) & ((1 << (IEC61131ParserParser.REAL - 165)) | (1 << (IEC61131ParserParser.BYTE - 165)) | (1 << (IEC61131ParserParser.WORD - 165)) | (1 << (IEC61131ParserParser.BOOL - 165)) | (1 << (IEC61131ParserParser.UINT - 165)) | (1 << (IEC61131ParserParser.SINT - 165)) | (1 << (IEC61131ParserParser.DINT - 165)) | (1 << (IEC61131ParserParser.INT - 165)))) != 0)):
                    localctx.name = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 257
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.R_EDGE or _la==IEC61131ParserParser.F_EDGE:
                    self.state = 256
                    localctx.attr = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==IEC61131ParserParser.R_EDGE or _la==IEC61131ParserParser.F_EDGE):
                        localctx.attr = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            elif token in [IEC61131ParserParser.TIME]:
                localctx = IEC61131ParserParser.TimeDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 259
                localctx.name = self.match(IEC61131ParserParser.TIME)
                pass
            elif token in [IEC61131ParserParser.ARRAY]:
                localctx = IEC61131ParserParser.ArrayDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 260
                localctx.name = self.match(IEC61131ParserParser.ARRAY)
                self.state = 261
                self.match(IEC61131ParserParser.T__3)
                self.state = 262
                localctx.ranfrom = self.uns_int()
                self.state = 263
                self.match(IEC61131ParserParser.T__4)
                self.state = 264
                localctx.ranto = self.uns_int()
                self.state = 265
                self.match(IEC61131ParserParser.T__5)
                self.state = 266
                self.match(IEC61131ParserParser.OF)
                self.state = 267
                localctx.dt = self.data_type()
                pass
            elif token in [IEC61131ParserParser.R_TRIG, IEC61131ParserParser.F_TRIG, IEC61131ParserParser.CTUD, IEC61131ParserParser.CTU, IEC61131ParserParser.CTD, IEC61131ParserParser.TON, IEC61131ParserParser.TOF, IEC61131ParserParser.TP, IEC61131ParserParser.SR, IEC61131ParserParser.RS]:
                localctx = IEC61131ParserParser.StdFbDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 269
                localctx.name = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & ((1 << (IEC61131ParserParser.R_TRIG - 127)) | (1 << (IEC61131ParserParser.F_TRIG - 127)) | (1 << (IEC61131ParserParser.CTUD - 127)))) != 0) or ((((_la - 220)) & ~0x3f) == 0 and ((1 << (_la - 220)) & ((1 << (IEC61131ParserParser.CTU - 220)) | (1 << (IEC61131ParserParser.CTD - 220)) | (1 << (IEC61131ParserParser.TON - 220)) | (1 << (IEC61131ParserParser.TOF - 220)) | (1 << (IEC61131ParserParser.TP - 220)) | (1 << (IEC61131ParserParser.SR - 220)) | (1 << (IEC61131ParserParser.RS - 220)))) != 0)):
                    localctx.name = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [IEC61131ParserParser.IDENTIFIER]:
                localctx = IEC61131ParserParser.UsrFbDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 270
                localctx.name = self.match(IEC61131ParserParser.IDENTIFIER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_instruction

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class InstrFullContext(InstructionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.InstructionContext
            super().__init__(parser)
            self.lab = None # LabelContext
            self.instr = None # Il_instructionContext
            self.copyFrom(ctx)

        def label(self):
            return self.getTypedRuleContext(IEC61131ParserParser.LabelContext,0)

        def il_instruction(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_instructionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstrFull" ):
                return visitor.visitInstrFull(self)
            else:
                return visitor.visitChildren(self)


    class InstrLabelContext(InstructionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.InstructionContext
            super().__init__(parser)
            self.lab = None # LabelContext
            self.copyFrom(ctx)

        def label(self):
            return self.getTypedRuleContext(IEC61131ParserParser.LabelContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstrLabel" ):
                return visitor.visitInstrLabel(self)
            else:
                return visitor.visitChildren(self)


    class InstrIlInstrContext(InstructionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.InstructionContext
            super().__init__(parser)
            self.instr = None # Il_instructionContext
            self.copyFrom(ctx)

        def il_instruction(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_instructionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstrIlInstr" ):
                return visitor.visitInstrIlInstr(self)
            else:
                return visitor.visitChildren(self)



    def instruction(self):

        localctx = IEC61131ParserParser.InstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_instruction)
        try:
            self.state = 281
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                localctx = IEC61131ParserParser.InstrFullContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 273
                localctx.lab = self.label()
                self.state = 274
                self.match(IEC61131ParserParser.T__1)
                self.state = 275
                localctx.instr = self.il_instruction()
                pass

            elif la_ == 2:
                localctx = IEC61131ParserParser.InstrLabelContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 277
                localctx.lab = self.label()
                self.state = 278
                self.match(IEC61131ParserParser.T__1)
                pass

            elif la_ == 3:
                localctx = IEC61131ParserParser.InstrIlInstrContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 280
                localctx.instr = self.il_instruction()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(IEC61131ParserParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_label

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabel" ):
                return visitor.visitLabel(self)
            else:
                return visitor.visitChildren(self)




    def label(self):

        localctx = IEC61131ParserParser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            self.match(IEC61131ParserParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Il_instructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_instruction

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IlInstrZeroaryContext(Il_instructionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Il_instructionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def il_expr_uop(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_expr_uopContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIlInstrZeroary" ):
                return visitor.visitIlInstrZeroary(self)
            else:
                return visitor.visitChildren(self)


    class IlInstrJumpContext(Il_instructionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Il_instructionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def label(self):
            return self.getTypedRuleContext(IEC61131ParserParser.LabelContext,0)

        def JMP(self):
            return self.getToken(IEC61131ParserParser.JMP, 0)
        def JMPC(self):
            return self.getToken(IEC61131ParserParser.JMPC, 0)
        def JMPCN(self):
            return self.getToken(IEC61131ParserParser.JMPCN, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIlInstrJump" ):
                return visitor.visitIlInstrJump(self)
            else:
                return visitor.visitChildren(self)


    class IlInstrUnarySimpleContext(Il_instructionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Il_instructionContext
            super().__init__(parser)
            self.expr = None # Il_exprContext
            self.copyFrom(ctx)

        def il_instr_op(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_instr_opContext,0)

        def il_expr(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_exprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIlInstrUnarySimple" ):
                return visitor.visitIlInstrUnarySimple(self)
            else:
                return visitor.visitChildren(self)


    class IlInstrCallContext(Il_instructionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Il_instructionContext
            super().__init__(parser)
            self.op = None # Token
            self.params = None # Il_call_parsContext
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(IEC61131ParserParser.IDENTIFIER, 0)
        def CAL(self):
            return self.getToken(IEC61131ParserParser.CAL, 0)
        def CALC(self):
            return self.getToken(IEC61131ParserParser.CALC, 0)
        def CALCN(self):
            return self.getToken(IEC61131ParserParser.CALCN, 0)
        def il_call_pars(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_call_parsContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIlInstrCall" ):
                return visitor.visitIlInstrCall(self)
            else:
                return visitor.visitChildren(self)


    class IlInstrUnaryExprContext(Il_instructionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Il_instructionContext
            super().__init__(parser)
            self.bop = None # Il_expr_bopContext
            self.expr = None # Il_exprContext
            self.copyFrom(ctx)

        def il_expr_bop(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_expr_bopContext,0)

        def il_expr(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_exprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIlInstrUnaryExpr" ):
                return visitor.visitIlInstrUnaryExpr(self)
            else:
                return visitor.visitChildren(self)


    class IlInstrReturnContext(Il_instructionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Il_instructionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def RET(self):
            return self.getToken(IEC61131ParserParser.RET, 0)
        def RETC(self):
            return self.getToken(IEC61131ParserParser.RETC, 0)
        def RETCN(self):
            return self.getToken(IEC61131ParserParser.RETCN, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIlInstrReturn" ):
                return visitor.visitIlInstrReturn(self)
            else:
                return visitor.visitChildren(self)



    def il_instruction(self):

        localctx = IEC61131ParserParser.Il_instructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_il_instruction)
        self._la = 0 # Token type
        try:
            self.state = 308
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                localctx = IEC61131ParserParser.IlInstrUnarySimpleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 285
                self.il_instr_op()
                self.state = 286
                localctx.expr = self.il_expr()
                pass

            elif la_ == 2:
                localctx = IEC61131ParserParser.IlInstrUnaryExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 288
                localctx.bop = self.il_expr_bop()
                self.state = 289
                localctx.expr = self.il_expr()
                pass

            elif la_ == 3:
                localctx = IEC61131ParserParser.IlInstrUnaryExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 291
                localctx.bop = self.il_expr_bop()
                self.state = 292
                self.match(IEC61131ParserParser.T__6)
                self.state = 293
                localctx.expr = self.il_expr()
                self.state = 294
                self.match(IEC61131ParserParser.T__7)
                pass

            elif la_ == 4:
                localctx = IEC61131ParserParser.IlInstrZeroaryContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 296
                self.il_expr_uop()
                pass

            elif la_ == 5:
                localctx = IEC61131ParserParser.IlInstrCallContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 297
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 151)) & ~0x3f) == 0 and ((1 << (_la - 151)) & ((1 << (IEC61131ParserParser.CALCN - 151)) | (1 << (IEC61131ParserParser.CALC - 151)) | (1 << (IEC61131ParserParser.CAL - 151)))) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 298
                self.match(IEC61131ParserParser.IDENTIFIER)
                self.state = 303
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IEC61131ParserParser.T__6:
                    self.state = 299
                    self.match(IEC61131ParserParser.T__6)
                    self.state = 300
                    localctx.params = self.il_call_pars()
                    self.state = 301
                    self.match(IEC61131ParserParser.T__7)


                pass

            elif la_ == 6:
                localctx = IEC61131ParserParser.IlInstrJumpContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 305
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==IEC61131ParserParser.JMPCN or _la==IEC61131ParserParser.JMPC or _la==IEC61131ParserParser.JMP):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 306
                self.label()
                pass

            elif la_ == 7:
                localctx = IEC61131ParserParser.IlInstrReturnContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 307
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==IEC61131ParserParser.RETCN or _la==IEC61131ParserParser.RETC or _la==IEC61131ParserParser.RET):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Il_instr_opContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LD(self):
            return self.getToken(IEC61131ParserParser.LD, 0)

        def LDN(self):
            return self.getToken(IEC61131ParserParser.LDN, 0)

        def ST(self):
            return self.getToken(IEC61131ParserParser.ST, 0)

        def STN(self):
            return self.getToken(IEC61131ParserParser.STN, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_instr_op

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIl_instr_op" ):
                return visitor.visitIl_instr_op(self)
            else:
                return visitor.visitChildren(self)




    def il_instr_op(self):

        localctx = IEC61131ParserParser.Il_instr_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_il_instr_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            _la = self._input.LA(1)
            if not(_la==IEC61131ParserParser.T__8 or _la==IEC61131ParserParser.T__9 or ((((_la - 209)) & ~0x3f) == 0 and ((1 << (_la - 209)) & ((1 << (IEC61131ParserParser.STN - 209)) | (1 << (IEC61131ParserParser.LDN - 209)) | (1 << (IEC61131ParserParser.LD - 209)) | (1 << (IEC61131ParserParser.ST - 209)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Il_expr_uopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(IEC61131ParserParser.NOT, 0)

        def conversion_function(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Conversion_functionContext,0)


        def std_func_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Std_func_nameContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_expr_uop

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIl_expr_uop" ):
                return visitor.visitIl_expr_uop(self)
            else:
                return visitor.visitChildren(self)




    def il_expr_uop(self):

        localctx = IEC61131ParserParser.Il_expr_uopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_il_expr_uop)
        try:
            self.state = 315
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 312
                self.match(IEC61131ParserParser.NOT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 313
                self.conversion_function()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 314
                self.std_func_name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Il_expr_bopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(IEC61131ParserParser.AND, 0)

        def OR(self):
            return self.getToken(IEC61131ParserParser.OR, 0)

        def XOR(self):
            return self.getToken(IEC61131ParserParser.XOR, 0)

        def ANDN(self):
            return self.getToken(IEC61131ParserParser.ANDN, 0)

        def ORN(self):
            return self.getToken(IEC61131ParserParser.ORN, 0)

        def XORN(self):
            return self.getToken(IEC61131ParserParser.XORN, 0)

        def ADD(self):
            return self.getToken(IEC61131ParserParser.ADD, 0)

        def SUB(self):
            return self.getToken(IEC61131ParserParser.SUB, 0)

        def MUL(self):
            return self.getToken(IEC61131ParserParser.MUL, 0)

        def DIV(self):
            return self.getToken(IEC61131ParserParser.DIV, 0)

        def MOD(self):
            return self.getToken(IEC61131ParserParser.MOD, 0)

        def GT(self):
            return self.getToken(IEC61131ParserParser.GT, 0)

        def GE(self):
            return self.getToken(IEC61131ParserParser.GE, 0)

        def EQ(self):
            return self.getToken(IEC61131ParserParser.EQ, 0)

        def LT(self):
            return self.getToken(IEC61131ParserParser.LT, 0)

        def LE(self):
            return self.getToken(IEC61131ParserParser.LE, 0)

        def NE(self):
            return self.getToken(IEC61131ParserParser.NE, 0)

        def SHR(self):
            return self.getToken(IEC61131ParserParser.SHR, 0)

        def SHL(self):
            return self.getToken(IEC61131ParserParser.SHL, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_expr_bop

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIl_expr_bop" ):
                return visitor.visitIl_expr_bop(self)
            else:
                return visitor.visitChildren(self)




    def il_expr_bop(self):

        localctx = IEC61131ParserParser.Il_expr_bopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_il_expr_bop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 317
            _la = self._input.LA(1)
            if not(((((_la - 184)) & ~0x3f) == 0 and ((1 << (_la - 184)) & ((1 << (IEC61131ParserParser.ANDN - 184)) | (1 << (IEC61131ParserParser.XORN - 184)) | (1 << (IEC61131ParserParser.MUL - 184)) | (1 << (IEC61131ParserParser.ADD - 184)) | (1 << (IEC61131ParserParser.AND - 184)) | (1 << (IEC61131ParserParser.XOR - 184)) | (1 << (IEC61131ParserParser.ORN - 184)) | (1 << (IEC61131ParserParser.SUB - 184)) | (1 << (IEC61131ParserParser.MOD - 184)) | (1 << (IEC61131ParserParser.DIV - 184)) | (1 << (IEC61131ParserParser.SHL - 184)) | (1 << (IEC61131ParserParser.SHR - 184)))) != 0) or ((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & ((1 << (IEC61131ParserParser.OR - 260)) | (1 << (IEC61131ParserParser.GT - 260)) | (1 << (IEC61131ParserParser.GE - 260)) | (1 << (IEC61131ParserParser.EQ - 260)) | (1 << (IEC61131ParserParser.LT - 260)) | (1 << (IEC61131ParserParser.LE - 260)) | (1 << (IEC61131ParserParser.NE - 260)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Il_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IlExprSimpleContext(Il_exprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Il_exprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def il_expr_simple(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_expr_simpleContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIlExprSimple" ):
                return visitor.visitIlExprSimple(self)
            else:
                return visitor.visitChildren(self)


    class IlExprComplexContext(Il_exprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Il_exprContext
            super().__init__(parser)
            self.simple = None # Il_expr_simpleContext
            self.lst = None # Il_instruction_listContext
            self.copyFrom(ctx)

        def il_expr_simple(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_expr_simpleContext,0)

        def il_instruction_list(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_instruction_listContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIlExprComplex" ):
                return visitor.visitIlExprComplex(self)
            else:
                return visitor.visitChildren(self)



    def il_expr(self):

        localctx = IEC61131ParserParser.Il_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_il_expr)
        self._la = 0 # Token type
        try:
            self.state = 327
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IEC61131ParserParser.T__6]:
                localctx = IEC61131ParserParser.IlExprComplexContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 319
                self.match(IEC61131ParserParser.T__6)
                self.state = 320
                localctx.simple = self.il_expr_simple(0)
                self.state = 322
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << IEC61131ParserParser.T__8) | (1 << IEC61131ParserParser.T__9) | (1 << IEC61131ParserParser.UDINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UDINT) | (1 << IEC61131ParserParser.DINT_TO_UDINT) | (1 << IEC61131ParserParser.UDINT_TO_DINT) | (1 << IEC61131ParserParser.UINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_BYTE) | (1 << IEC61131ParserParser.BYTE_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UINT) | (1 << IEC61131ParserParser.USINT_TO_DINT) | (1 << IEC61131ParserParser.DINT_TO_USINT) | (1 << IEC61131ParserParser.BYTE_TO_WORD) | (1 << IEC61131ParserParser.BYTE_TO_UINT) | (1 << IEC61131ParserParser.WORD_TO_BYTE) | (1 << IEC61131ParserParser.WORD_TO_UINT) | (1 << IEC61131ParserParser.REAL_TO_UINT) | (1 << IEC61131ParserParser.INT_TO_USINT) | (1 << IEC61131ParserParser.UINT_TO_BOOL) | (1 << IEC61131ParserParser.UINT_TO_WORD) | (1 << IEC61131ParserParser.UINT_TO_REAL) | (1 << IEC61131ParserParser.DINT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_DINT) | (1 << IEC61131ParserParser.WORD_TO_INT) | (1 << IEC61131ParserParser.REAL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_BOOL) | (1 << IEC61131ParserParser.BOOL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_WORD) | (1 << IEC61131ParserParser.INT_TO_REAL) | (1 << IEC61131ParserParser.INT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_INT))) != 0) or ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & ((1 << (IEC61131ParserParser.REPLACE - 116)) | (1 << (IEC61131ParserParser.INSERT - 116)) | (1 << (IEC61131ParserParser.DELETE - 116)) | (1 << (IEC61131ParserParser.CONCAT - 116)) | (1 << (IEC61131ParserParser.CALCN - 116)) | (1 << (IEC61131ParserParser.RETCN - 116)) | (1 << (IEC61131ParserParser.JMPCN - 116)) | (1 << (IEC61131ParserParser.RIGHT - 116)) | (1 << (IEC61131ParserParser.LIMIT - 116)) | (1 << (IEC61131ParserParser.TRUNC - 116)) | (1 << (IEC61131ParserParser.ATAN2 - 116)) | (1 << (IEC61131ParserParser.CALC - 116)))) != 0) or ((((_la - 184)) & ~0x3f) == 0 and ((1 << (_la - 184)) & ((1 << (IEC61131ParserParser.ANDN - 184)) | (1 << (IEC61131ParserParser.XORN - 184)) | (1 << (IEC61131ParserParser.RETC - 184)) | (1 << (IEC61131ParserParser.JMPC - 184)) | (1 << (IEC61131ParserParser.SQRT - 184)) | (1 << (IEC61131ParserParser.ASIN - 184)) | (1 << (IEC61131ParserParser.ACOS - 184)) | (1 << (IEC61131ParserParser.ATAN - 184)) | (1 << (IEC61131ParserParser.EXPT - 184)) | (1 << (IEC61131ParserParser.MOVE - 184)) | (1 << (IEC61131ParserParser.LEFT - 184)) | (1 << (IEC61131ParserParser.FIND - 184)) | (1 << (IEC61131ParserParser.NOT - 184)) | (1 << (IEC61131ParserParser.MUL - 184)) | (1 << (IEC61131ParserParser.ADD - 184)) | (1 << (IEC61131ParserParser.CAL - 184)) | (1 << (IEC61131ParserParser.STN - 184)) | (1 << (IEC61131ParserParser.LDN - 184)) | (1 << (IEC61131ParserParser.AND - 184)) | (1 << (IEC61131ParserParser.XOR - 184)) | (1 << (IEC61131ParserParser.ORN - 184)) | (1 << (IEC61131ParserParser.SUB - 184)) | (1 << (IEC61131ParserParser.MOD - 184)) | (1 << (IEC61131ParserParser.DIV - 184)) | (1 << (IEC61131ParserParser.RET - 184)) | (1 << (IEC61131ParserParser.JMP - 184)) | (1 << (IEC61131ParserParser.ABS - 184)) | (1 << (IEC61131ParserParser.LOG - 184)) | (1 << (IEC61131ParserParser.EXP - 184)) | (1 << (IEC61131ParserParser.SIN - 184)) | (1 << (IEC61131ParserParser.COS - 184)) | (1 << (IEC61131ParserParser.TAN - 184)) | (1 << (IEC61131ParserParser.SHL - 184)) | (1 << (IEC61131ParserParser.SHR - 184)) | (1 << (IEC61131ParserParser.ROL - 184)) | (1 << (IEC61131ParserParser.ROR - 184)) | (1 << (IEC61131ParserParser.SEL - 184)) | (1 << (IEC61131ParserParser.MAX - 184)) | (1 << (IEC61131ParserParser.MIN - 184)) | (1 << (IEC61131ParserParser.MUX - 184)) | (1 << (IEC61131ParserParser.LEN - 184)) | (1 << (IEC61131ParserParser.MID - 184)))) != 0) or ((((_la - 255)) & ~0x3f) == 0 and ((1 << (_la - 255)) & ((1 << (IEC61131ParserParser.LD - 255)) | (1 << (IEC61131ParserParser.ST - 255)) | (1 << (IEC61131ParserParser.OR - 255)) | (1 << (IEC61131ParserParser.GT - 255)) | (1 << (IEC61131ParserParser.GE - 255)) | (1 << (IEC61131ParserParser.EQ - 255)) | (1 << (IEC61131ParserParser.LT - 255)) | (1 << (IEC61131ParserParser.LE - 255)) | (1 << (IEC61131ParserParser.NE - 255)) | (1 << (IEC61131ParserParser.LN - 255)))) != 0):
                    self.state = 321
                    localctx.lst = self.il_instruction_list()


                self.state = 324
                self.match(IEC61131ParserParser.T__7)
                pass
            elif token in [IEC61131ParserParser.T__20, IEC61131ParserParser.T__21, IEC61131ParserParser.TIME_MS, IEC61131ParserParser.TIME_S, IEC61131ParserParser.FALSE, IEC61131ParserParser.LREAL, IEC61131ParserParser.REAL, IEC61131ParserParser.TRUE, IEC61131ParserParser.BOOL, IEC61131ParserParser.SINT, IEC61131ParserParser.DINT, IEC61131ParserParser.INT, IEC61131ParserParser.IDENTIFIER, IEC61131ParserParser.DIGITS, IEC61131ParserParser.BINARY_INT, IEC61131ParserParser.OCTAL_INT, IEC61131ParserParser.HEX_INT]:
                localctx = IEC61131ParserParser.IlExprSimpleContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 326
                self.il_expr_simple(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Il_instruction_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def il_instruction_one(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Il_instruction_oneContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Il_instruction_oneContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_instruction_list

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIl_instruction_list" ):
                return visitor.visitIl_instruction_list(self)
            else:
                return visitor.visitChildren(self)




    def il_instruction_list(self):

        localctx = IEC61131ParserParser.Il_instruction_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_il_instruction_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 330 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 329
                self.il_instruction_one()
                self.state = 332 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << IEC61131ParserParser.T__8) | (1 << IEC61131ParserParser.T__9) | (1 << IEC61131ParserParser.UDINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UDINT) | (1 << IEC61131ParserParser.DINT_TO_UDINT) | (1 << IEC61131ParserParser.UDINT_TO_DINT) | (1 << IEC61131ParserParser.UINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_BYTE) | (1 << IEC61131ParserParser.BYTE_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UINT) | (1 << IEC61131ParserParser.USINT_TO_DINT) | (1 << IEC61131ParserParser.DINT_TO_USINT) | (1 << IEC61131ParserParser.BYTE_TO_WORD) | (1 << IEC61131ParserParser.BYTE_TO_UINT) | (1 << IEC61131ParserParser.WORD_TO_BYTE) | (1 << IEC61131ParserParser.WORD_TO_UINT) | (1 << IEC61131ParserParser.REAL_TO_UINT) | (1 << IEC61131ParserParser.INT_TO_USINT) | (1 << IEC61131ParserParser.UINT_TO_BOOL) | (1 << IEC61131ParserParser.UINT_TO_WORD) | (1 << IEC61131ParserParser.UINT_TO_REAL) | (1 << IEC61131ParserParser.DINT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_DINT) | (1 << IEC61131ParserParser.WORD_TO_INT) | (1 << IEC61131ParserParser.REAL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_BOOL) | (1 << IEC61131ParserParser.BOOL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_WORD) | (1 << IEC61131ParserParser.INT_TO_REAL) | (1 << IEC61131ParserParser.INT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_INT))) != 0) or ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & ((1 << (IEC61131ParserParser.REPLACE - 116)) | (1 << (IEC61131ParserParser.INSERT - 116)) | (1 << (IEC61131ParserParser.DELETE - 116)) | (1 << (IEC61131ParserParser.CONCAT - 116)) | (1 << (IEC61131ParserParser.CALCN - 116)) | (1 << (IEC61131ParserParser.RETCN - 116)) | (1 << (IEC61131ParserParser.JMPCN - 116)) | (1 << (IEC61131ParserParser.RIGHT - 116)) | (1 << (IEC61131ParserParser.LIMIT - 116)) | (1 << (IEC61131ParserParser.TRUNC - 116)) | (1 << (IEC61131ParserParser.ATAN2 - 116)) | (1 << (IEC61131ParserParser.CALC - 116)))) != 0) or ((((_la - 184)) & ~0x3f) == 0 and ((1 << (_la - 184)) & ((1 << (IEC61131ParserParser.ANDN - 184)) | (1 << (IEC61131ParserParser.XORN - 184)) | (1 << (IEC61131ParserParser.RETC - 184)) | (1 << (IEC61131ParserParser.JMPC - 184)) | (1 << (IEC61131ParserParser.SQRT - 184)) | (1 << (IEC61131ParserParser.ASIN - 184)) | (1 << (IEC61131ParserParser.ACOS - 184)) | (1 << (IEC61131ParserParser.ATAN - 184)) | (1 << (IEC61131ParserParser.EXPT - 184)) | (1 << (IEC61131ParserParser.MOVE - 184)) | (1 << (IEC61131ParserParser.LEFT - 184)) | (1 << (IEC61131ParserParser.FIND - 184)) | (1 << (IEC61131ParserParser.NOT - 184)) | (1 << (IEC61131ParserParser.MUL - 184)) | (1 << (IEC61131ParserParser.ADD - 184)) | (1 << (IEC61131ParserParser.CAL - 184)) | (1 << (IEC61131ParserParser.STN - 184)) | (1 << (IEC61131ParserParser.LDN - 184)) | (1 << (IEC61131ParserParser.AND - 184)) | (1 << (IEC61131ParserParser.XOR - 184)) | (1 << (IEC61131ParserParser.ORN - 184)) | (1 << (IEC61131ParserParser.SUB - 184)) | (1 << (IEC61131ParserParser.MOD - 184)) | (1 << (IEC61131ParserParser.DIV - 184)) | (1 << (IEC61131ParserParser.RET - 184)) | (1 << (IEC61131ParserParser.JMP - 184)) | (1 << (IEC61131ParserParser.ABS - 184)) | (1 << (IEC61131ParserParser.LOG - 184)) | (1 << (IEC61131ParserParser.EXP - 184)) | (1 << (IEC61131ParserParser.SIN - 184)) | (1 << (IEC61131ParserParser.COS - 184)) | (1 << (IEC61131ParserParser.TAN - 184)) | (1 << (IEC61131ParserParser.SHL - 184)) | (1 << (IEC61131ParserParser.SHR - 184)) | (1 << (IEC61131ParserParser.ROL - 184)) | (1 << (IEC61131ParserParser.ROR - 184)) | (1 << (IEC61131ParserParser.SEL - 184)) | (1 << (IEC61131ParserParser.MAX - 184)) | (1 << (IEC61131ParserParser.MIN - 184)) | (1 << (IEC61131ParserParser.MUX - 184)) | (1 << (IEC61131ParserParser.LEN - 184)) | (1 << (IEC61131ParserParser.MID - 184)))) != 0) or ((((_la - 255)) & ~0x3f) == 0 and ((1 << (_la - 255)) & ((1 << (IEC61131ParserParser.LD - 255)) | (1 << (IEC61131ParserParser.ST - 255)) | (1 << (IEC61131ParserParser.OR - 255)) | (1 << (IEC61131ParserParser.GT - 255)) | (1 << (IEC61131ParserParser.GE - 255)) | (1 << (IEC61131ParserParser.EQ - 255)) | (1 << (IEC61131ParserParser.LT - 255)) | (1 << (IEC61131ParserParser.LE - 255)) | (1 << (IEC61131ParserParser.NE - 255)) | (1 << (IEC61131ParserParser.LN - 255)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Il_instruction_oneContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def il_instruction(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_instructionContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_instruction_one

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIl_instruction_one" ):
                return visitor.visitIl_instruction_one(self)
            else:
                return visitor.visitChildren(self)




    def il_instruction_one(self):

        localctx = IEC61131ParserParser.Il_instruction_oneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_il_instruction_one)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            self.il_instruction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Il_expr_simpleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ConstantContext,0)


        def variable_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_nameContext,0)


        def array_access(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Array_accessContext,0)


        def composite_access(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Composite_accessContext,0)


        def il_expr_simple(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_expr_simpleContext,0)


        def uns_int(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Uns_intContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_expr_simple

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIl_expr_simple" ):
                return visitor.visitIl_expr_simple(self)
            else:
                return visitor.visitChildren(self)



    def il_expr_simple(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = IEC61131ParserParser.Il_expr_simpleContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 38
        self.enterRecursionRule(localctx, 38, self.RULE_il_expr_simple, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 341
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.state = 337
                self.constant()
                pass

            elif la_ == 2:
                self.state = 338
                self.variable_name()
                pass

            elif la_ == 3:
                self.state = 339
                self.array_access()
                pass

            elif la_ == 4:
                self.state = 340
                self.composite_access()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 348
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,33,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = IEC61131ParserParser.Il_expr_simpleContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_il_expr_simple)
                    self.state = 343
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 344
                    self.match(IEC61131ParserParser.T__10)
                    self.state = 345
                    self.uns_int() 
                self.state = 350
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Il_call_parsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def il_call_args(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_call_argsContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_call_pars

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIl_call_pars" ):
                return visitor.visitIl_call_pars(self)
            else:
                return visitor.visitChildren(self)




    def il_call_pars(self):

        localctx = IEC61131ParserParser.Il_call_parsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_il_call_pars)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 351
            self.il_call_args()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Il_call_argsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def il_call_arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Il_call_argContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Il_call_argContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_call_args

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIl_call_args" ):
                return visitor.visitIl_call_args(self)
            else:
                return visitor.visitChildren(self)




    def il_call_args(self):

        localctx = IEC61131ParserParser.Il_call_argsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_il_call_args)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 353
            self.il_call_arg()
            self.state = 358
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==IEC61131ParserParser.T__11:
                self.state = 354
                self.match(IEC61131ParserParser.T__11)
                self.state = 355
                self.il_call_arg()
                self.state = 360
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Il_call_argContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.param1 = None # Variable_nameContext
            self.param2 = None # Il_exprContext

        def variable_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_nameContext,0)


        def il_expr(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Il_exprContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_il_call_arg

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIl_call_arg" ):
                return visitor.visitIl_call_arg(self)
            else:
                return visitor.visitChildren(self)




    def il_call_arg(self):

        localctx = IEC61131ParserParser.Il_call_argContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_il_call_arg)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 362
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==IEC61131ParserParser.IDENTIFIER:
                self.state = 361
                localctx.param1 = self.variable_name()


            self.state = 364
            self.match(IEC61131ParserParser.T__2)
            self.state = 366
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << IEC61131ParserParser.T__6) | (1 << IEC61131ParserParser.T__20) | (1 << IEC61131ParserParser.T__21))) != 0) or ((((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & ((1 << (IEC61131ParserParser.TIME_MS - 110)) | (1 << (IEC61131ParserParser.TIME_S - 110)) | (1 << (IEC61131ParserParser.FALSE - 110)) | (1 << (IEC61131ParserParser.LREAL - 110)) | (1 << (IEC61131ParserParser.REAL - 110)) | (1 << (IEC61131ParserParser.TRUE - 110)) | (1 << (IEC61131ParserParser.BOOL - 110)))) != 0) or ((((_la - 181)) & ~0x3f) == 0 and ((1 << (_la - 181)) & ((1 << (IEC61131ParserParser.SINT - 181)) | (1 << (IEC61131ParserParser.DINT - 181)) | (1 << (IEC61131ParserParser.INT - 181)))) != 0) or ((((_la - 270)) & ~0x3f) == 0 and ((1 << (_la - 270)) & ((1 << (IEC61131ParserParser.IDENTIFIER - 270)) | (1 << (IEC61131ParserParser.DIGITS - 270)) | (1 << (IEC61131ParserParser.BINARY_INT - 270)) | (1 << (IEC61131ParserParser.OCTAL_INT - 270)) | (1 << (IEC61131ParserParser.HEX_INT - 270)))) != 0):
                self.state = 365
                localctx.param2 = self.il_expr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class St_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assign_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Assign_stmtContext,0)


        def if_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.If_stmtContext,0)


        def case_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Case_stmtContext,0)


        def while_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.While_stmtContext,0)


        def for_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.For_stmtContext,0)


        def repeat_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Repeat_stmtContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_st_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSt_stmt" ):
                return visitor.visitSt_stmt(self)
            else:
                return visitor.visitChildren(self)




    def st_stmt(self):

        localctx = IEC61131ParserParser.St_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_st_stmt)
        try:
            self.state = 386
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IEC61131ParserParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 368
                self.assign_stmt()
                self.state = 369
                self.match(IEC61131ParserParser.T__0)
                pass
            elif token in [IEC61131ParserParser.IF]:
                self.enterOuterAlt(localctx, 2)
                self.state = 371
                self.if_stmt()
                self.state = 372
                self.match(IEC61131ParserParser.T__0)
                pass
            elif token in [IEC61131ParserParser.CASE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 374
                self.case_stmt()
                self.state = 375
                self.match(IEC61131ParserParser.T__0)
                pass
            elif token in [IEC61131ParserParser.WHILE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 377
                self.while_stmt()
                self.state = 378
                self.match(IEC61131ParserParser.T__0)
                pass
            elif token in [IEC61131ParserParser.FOR]:
                self.enterOuterAlt(localctx, 5)
                self.state = 380
                self.for_stmt()
                self.state = 381
                self.match(IEC61131ParserParser.T__0)
                pass
            elif token in [IEC61131ParserParser.REPEAT]:
                self.enterOuterAlt(localctx, 6)
                self.state = 383
                self.repeat_stmt()
                self.state = 384
                self.match(IEC61131ParserParser.T__0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Assign_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_assign_stmt

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AssignCompositeAccessContext(Assign_stmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Assign_stmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def composite_access(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Composite_accessContext,0)

        def expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignCompositeAccess" ):
                return visitor.visitAssignCompositeAccess(self)
            else:
                return visitor.visitChildren(self)


    class AssignArrayCellContext(Assign_stmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Assign_stmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def array_access(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Array_accessContext,0)

        def expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignArrayCell" ):
                return visitor.visitAssignArrayCell(self)
            else:
                return visitor.visitChildren(self)


    class AssignVariableContext(Assign_stmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Assign_stmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def simple_var(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Simple_varContext,0)

        def expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignVariable" ):
                return visitor.visitAssignVariable(self)
            else:
                return visitor.visitChildren(self)


    class AssignBitAccessContext(Assign_stmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Assign_stmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def variable_bit_access(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_bit_accessContext,0)

        def expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignBitAccess" ):
                return visitor.visitAssignBitAccess(self)
            else:
                return visitor.visitChildren(self)



    def assign_stmt(self):

        localctx = IEC61131ParserParser.Assign_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_assign_stmt)
        try:
            self.state = 404
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                localctx = IEC61131ParserParser.AssignVariableContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 388
                self.simple_var()
                self.state = 389
                self.match(IEC61131ParserParser.T__2)
                self.state = 390
                self.expression()
                pass

            elif la_ == 2:
                localctx = IEC61131ParserParser.AssignArrayCellContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 392
                self.array_access()
                self.state = 393
                self.match(IEC61131ParserParser.T__2)
                self.state = 394
                self.expression()
                pass

            elif la_ == 3:
                localctx = IEC61131ParserParser.AssignBitAccessContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 396
                self.variable_bit_access()
                self.state = 397
                self.match(IEC61131ParserParser.T__2)
                self.state = 398
                self.expression()
                pass

            elif la_ == 4:
                localctx = IEC61131ParserParser.AssignCompositeAccessContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 400
                self.composite_access()
                self.state = 401
                self.match(IEC61131ParserParser.T__2)
                self.state = 402
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def if_simple_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.If_simple_stmtContext,0)


        def if_elseif_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.If_elseif_stmtContext,0)


        def if_else_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.If_else_stmtContext,0)


        def if_complete_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.If_complete_stmtContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_if_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf_stmt" ):
                return visitor.visitIf_stmt(self)
            else:
                return visitor.visitChildren(self)




    def if_stmt(self):

        localctx = IEC61131ParserParser.If_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_if_stmt)
        try:
            self.state = 410
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 406
                self.if_simple_stmt()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 407
                self.if_elseif_stmt()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 408
                self.if_else_stmt()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 409
                self.if_complete_stmt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_simple_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ifexpr = None # Bool_expressionContext
            self.ifstmt = None # Stmt_blockContext

        def IF(self):
            return self.getToken(IEC61131ParserParser.IF, 0)

        def THEN(self):
            return self.getToken(IEC61131ParserParser.THEN, 0)

        def END_IF(self):
            return self.getToken(IEC61131ParserParser.END_IF, 0)

        def bool_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Bool_expressionContext,0)


        def stmt_block(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Stmt_blockContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_if_simple_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf_simple_stmt" ):
                return visitor.visitIf_simple_stmt(self)
            else:
                return visitor.visitChildren(self)




    def if_simple_stmt(self):

        localctx = IEC61131ParserParser.If_simple_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_if_simple_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 412
            self.match(IEC61131ParserParser.IF)
            self.state = 413
            localctx.ifexpr = self.bool_expression(0)
            self.state = 414
            self.match(IEC61131ParserParser.THEN)
            self.state = 415
            localctx.ifstmt = self.stmt_block()
            self.state = 416
            self.match(IEC61131ParserParser.END_IF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_elseif_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ifexpr = None # Bool_expressionContext
            self.ifstmt = None # Stmt_blockContext
            self.elsifstmt = None # Elsif_stmt_listContext

        def IF(self):
            return self.getToken(IEC61131ParserParser.IF, 0)

        def THEN(self):
            return self.getToken(IEC61131ParserParser.THEN, 0)

        def END_IF(self):
            return self.getToken(IEC61131ParserParser.END_IF, 0)

        def bool_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Bool_expressionContext,0)


        def stmt_block(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Stmt_blockContext,0)


        def elsif_stmt_list(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Elsif_stmt_listContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_if_elseif_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf_elseif_stmt" ):
                return visitor.visitIf_elseif_stmt(self)
            else:
                return visitor.visitChildren(self)




    def if_elseif_stmt(self):

        localctx = IEC61131ParserParser.If_elseif_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_if_elseif_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            self.match(IEC61131ParserParser.IF)
            self.state = 419
            localctx.ifexpr = self.bool_expression(0)
            self.state = 420
            self.match(IEC61131ParserParser.THEN)
            self.state = 421
            localctx.ifstmt = self.stmt_block()
            self.state = 422
            localctx.elsifstmt = self.elsif_stmt_list()
            self.state = 423
            self.match(IEC61131ParserParser.END_IF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_else_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ifexpr = None # Bool_expressionContext
            self.ifstmt = None # Stmt_blockContext
            self.elsestmt = None # Else_stmtContext

        def IF(self):
            return self.getToken(IEC61131ParserParser.IF, 0)

        def THEN(self):
            return self.getToken(IEC61131ParserParser.THEN, 0)

        def END_IF(self):
            return self.getToken(IEC61131ParserParser.END_IF, 0)

        def bool_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Bool_expressionContext,0)


        def stmt_block(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Stmt_blockContext,0)


        def else_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Else_stmtContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_if_else_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf_else_stmt" ):
                return visitor.visitIf_else_stmt(self)
            else:
                return visitor.visitChildren(self)




    def if_else_stmt(self):

        localctx = IEC61131ParserParser.If_else_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_if_else_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 425
            self.match(IEC61131ParserParser.IF)
            self.state = 426
            localctx.ifexpr = self.bool_expression(0)
            self.state = 427
            self.match(IEC61131ParserParser.THEN)
            self.state = 428
            localctx.ifstmt = self.stmt_block()
            self.state = 429
            localctx.elsestmt = self.else_stmt()
            self.state = 430
            self.match(IEC61131ParserParser.END_IF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_complete_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ifexpr = None # Bool_expressionContext
            self.ifstmt = None # Stmt_blockContext
            self.elsifstmt = None # Elsif_stmt_listContext
            self.elsestmt = None # Else_stmtContext

        def IF(self):
            return self.getToken(IEC61131ParserParser.IF, 0)

        def THEN(self):
            return self.getToken(IEC61131ParserParser.THEN, 0)

        def END_IF(self):
            return self.getToken(IEC61131ParserParser.END_IF, 0)

        def bool_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Bool_expressionContext,0)


        def stmt_block(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Stmt_blockContext,0)


        def elsif_stmt_list(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Elsif_stmt_listContext,0)


        def else_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Else_stmtContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_if_complete_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf_complete_stmt" ):
                return visitor.visitIf_complete_stmt(self)
            else:
                return visitor.visitChildren(self)




    def if_complete_stmt(self):

        localctx = IEC61131ParserParser.If_complete_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_if_complete_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 432
            self.match(IEC61131ParserParser.IF)
            self.state = 433
            localctx.ifexpr = self.bool_expression(0)
            self.state = 434
            self.match(IEC61131ParserParser.THEN)
            self.state = 435
            localctx.ifstmt = self.stmt_block()
            self.state = 436
            localctx.elsifstmt = self.elsif_stmt_list()
            self.state = 437
            localctx.elsestmt = self.else_stmt()
            self.state = 438
            self.match(IEC61131ParserParser.END_IF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Elsif_stmt_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elsif_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Elsif_stmtContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Elsif_stmtContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_elsif_stmt_list

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElsif_stmt_list" ):
                return visitor.visitElsif_stmt_list(self)
            else:
                return visitor.visitChildren(self)




    def elsif_stmt_list(self):

        localctx = IEC61131ParserParser.Elsif_stmt_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_elsif_stmt_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 440
                self.elsif_stmt()
                self.state = 443 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==IEC61131ParserParser.ELSIF):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Elsif_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.expr = None # Bool_expressionContext
            self.stmtblock = None # Stmt_blockContext

        def ELSIF(self):
            return self.getToken(IEC61131ParserParser.ELSIF, 0)

        def THEN(self):
            return self.getToken(IEC61131ParserParser.THEN, 0)

        def bool_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Bool_expressionContext,0)


        def stmt_block(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Stmt_blockContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_elsif_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElsif_stmt" ):
                return visitor.visitElsif_stmt(self)
            else:
                return visitor.visitChildren(self)




    def elsif_stmt(self):

        localctx = IEC61131ParserParser.Elsif_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_elsif_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 445
            self.match(IEC61131ParserParser.ELSIF)
            self.state = 446
            localctx.expr = self.bool_expression(0)
            self.state = 447
            self.match(IEC61131ParserParser.THEN)
            self.state = 448
            localctx.stmtblock = self.stmt_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Else_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.stmtblock = None # Stmt_blockContext

        def ELSE(self):
            return self.getToken(IEC61131ParserParser.ELSE, 0)

        def stmt_block(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Stmt_blockContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_else_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElse_stmt" ):
                return visitor.visitElse_stmt(self)
            else:
                return visitor.visitChildren(self)




    def else_stmt(self):

        localctx = IEC61131ParserParser.Else_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_else_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 450
            self.match(IEC61131ParserParser.ELSE)
            self.state = 451
            localctx.stmtblock = self.stmt_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stmt_blockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def st_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.St_stmtContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.St_stmtContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_stmt_block

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStmt_block" ):
                return visitor.visitStmt_block(self)
            else:
                return visitor.visitChildren(self)




    def stmt_block(self):

        localctx = IEC61131ParserParser.Stmt_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_stmt_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 454 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 453
                    self.st_stmt()

                else:
                    raise NoViableAltException(self)
                self.state = 456 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Case_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.expr = None # ExpressionContext
            self.casesel = None # Case_selectionsContext
            self.elsestmt = None # Stmt_blockContext

        def CASE(self):
            return self.getToken(IEC61131ParserParser.CASE, 0)

        def OF(self):
            return self.getToken(IEC61131ParserParser.OF, 0)

        def END_CASE(self):
            return self.getToken(IEC61131ParserParser.END_CASE, 0)

        def expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ExpressionContext,0)


        def case_selections(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Case_selectionsContext,0)


        def ELSE(self):
            return self.getToken(IEC61131ParserParser.ELSE, 0)

        def stmt_block(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Stmt_blockContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_case_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCase_stmt" ):
                return visitor.visitCase_stmt(self)
            else:
                return visitor.visitChildren(self)




    def case_stmt(self):

        localctx = IEC61131ParserParser.Case_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_case_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 458
            self.match(IEC61131ParserParser.CASE)
            self.state = 459
            localctx.expr = self.expression()
            self.state = 460
            self.match(IEC61131ParserParser.OF)
            self.state = 461
            localctx.casesel = self.case_selections()
            self.state = 464
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==IEC61131ParserParser.ELSE:
                self.state = 462
                self.match(IEC61131ParserParser.ELSE)
                self.state = 463
                localctx.elsestmt = self.stmt_block()


            self.state = 466
            self.match(IEC61131ParserParser.END_CASE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Case_selectionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def case_selection(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Case_selectionContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Case_selectionContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_case_selections

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCase_selections" ):
                return visitor.visitCase_selections(self)
            else:
                return visitor.visitChildren(self)




    def case_selections(self):

        localctx = IEC61131ParserParser.Case_selectionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_case_selections)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 469 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 468
                self.case_selection()
                self.state = 471 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << IEC61131ParserParser.T__6) | (1 << IEC61131ParserParser.T__20) | (1 << IEC61131ParserParser.T__21) | (1 << IEC61131ParserParser.UDINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UDINT) | (1 << IEC61131ParserParser.DINT_TO_UDINT) | (1 << IEC61131ParserParser.UDINT_TO_DINT) | (1 << IEC61131ParserParser.UINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_BYTE) | (1 << IEC61131ParserParser.BYTE_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UINT) | (1 << IEC61131ParserParser.USINT_TO_DINT) | (1 << IEC61131ParserParser.DINT_TO_USINT) | (1 << IEC61131ParserParser.BYTE_TO_WORD) | (1 << IEC61131ParserParser.BYTE_TO_UINT) | (1 << IEC61131ParserParser.WORD_TO_BYTE) | (1 << IEC61131ParserParser.WORD_TO_UINT) | (1 << IEC61131ParserParser.REAL_TO_UINT) | (1 << IEC61131ParserParser.INT_TO_USINT) | (1 << IEC61131ParserParser.UINT_TO_BOOL) | (1 << IEC61131ParserParser.UINT_TO_WORD) | (1 << IEC61131ParserParser.UINT_TO_REAL) | (1 << IEC61131ParserParser.DINT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_DINT) | (1 << IEC61131ParserParser.WORD_TO_INT) | (1 << IEC61131ParserParser.REAL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_BOOL) | (1 << IEC61131ParserParser.BOOL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_WORD) | (1 << IEC61131ParserParser.INT_TO_REAL) | (1 << IEC61131ParserParser.INT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_INT))) != 0) or ((((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & ((1 << (IEC61131ParserParser.TIME_MS - 110)) | (1 << (IEC61131ParserParser.REPLACE - 110)) | (1 << (IEC61131ParserParser.TIME_S - 110)) | (1 << (IEC61131ParserParser.INSERT - 110)) | (1 << (IEC61131ParserParser.DELETE - 110)) | (1 << (IEC61131ParserParser.CONCAT - 110)) | (1 << (IEC61131ParserParser.FALSE - 110)) | (1 << (IEC61131ParserParser.LREAL - 110)) | (1 << (IEC61131ParserParser.RIGHT - 110)) | (1 << (IEC61131ParserParser.LIMIT - 110)) | (1 << (IEC61131ParserParser.TRUNC - 110)) | (1 << (IEC61131ParserParser.ATAN2 - 110)) | (1 << (IEC61131ParserParser.REAL - 110)) | (1 << (IEC61131ParserParser.TRUE - 110)) | (1 << (IEC61131ParserParser.BOOL - 110)))) != 0) or ((((_la - 181)) & ~0x3f) == 0 and ((1 << (_la - 181)) & ((1 << (IEC61131ParserParser.SINT - 181)) | (1 << (IEC61131ParserParser.DINT - 181)) | (1 << (IEC61131ParserParser.SQRT - 181)) | (1 << (IEC61131ParserParser.ASIN - 181)) | (1 << (IEC61131ParserParser.ACOS - 181)) | (1 << (IEC61131ParserParser.ATAN - 181)) | (1 << (IEC61131ParserParser.EXPT - 181)) | (1 << (IEC61131ParserParser.MOVE - 181)) | (1 << (IEC61131ParserParser.LEFT - 181)) | (1 << (IEC61131ParserParser.FIND - 181)) | (1 << (IEC61131ParserParser.INT - 181)) | (1 << (IEC61131ParserParser.NOT - 181)) | (1 << (IEC61131ParserParser.MUL - 181)) | (1 << (IEC61131ParserParser.ADD - 181)) | (1 << (IEC61131ParserParser.AND - 181)) | (1 << (IEC61131ParserParser.XOR - 181)) | (1 << (IEC61131ParserParser.SUB - 181)) | (1 << (IEC61131ParserParser.MOD - 181)) | (1 << (IEC61131ParserParser.DIV - 181)) | (1 << (IEC61131ParserParser.ABS - 181)) | (1 << (IEC61131ParserParser.LOG - 181)) | (1 << (IEC61131ParserParser.EXP - 181)) | (1 << (IEC61131ParserParser.SIN - 181)) | (1 << (IEC61131ParserParser.COS - 181)) | (1 << (IEC61131ParserParser.TAN - 181)) | (1 << (IEC61131ParserParser.SHL - 181)) | (1 << (IEC61131ParserParser.SHR - 181)) | (1 << (IEC61131ParserParser.ROL - 181)) | (1 << (IEC61131ParserParser.ROR - 181)) | (1 << (IEC61131ParserParser.SEL - 181)) | (1 << (IEC61131ParserParser.MAX - 181)) | (1 << (IEC61131ParserParser.MIN - 181)) | (1 << (IEC61131ParserParser.MUX - 181)) | (1 << (IEC61131ParserParser.LEN - 181)) | (1 << (IEC61131ParserParser.MID - 181)))) != 0) or ((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & ((1 << (IEC61131ParserParser.OR - 260)) | (1 << (IEC61131ParserParser.GT - 260)) | (1 << (IEC61131ParserParser.GE - 260)) | (1 << (IEC61131ParserParser.EQ - 260)) | (1 << (IEC61131ParserParser.LT - 260)) | (1 << (IEC61131ParserParser.LE - 260)) | (1 << (IEC61131ParserParser.NE - 260)) | (1 << (IEC61131ParserParser.LN - 260)) | (1 << (IEC61131ParserParser.IDENTIFIER - 260)) | (1 << (IEC61131ParserParser.DIGITS - 260)) | (1 << (IEC61131ParserParser.BINARY_INT - 260)) | (1 << (IEC61131ParserParser.OCTAL_INT - 260)) | (1 << (IEC61131ParserParser.HEX_INT - 260)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Case_selectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def case_list(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Case_listContext,0)


        def stmt_block(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Stmt_blockContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_case_selection

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCase_selection" ):
                return visitor.visitCase_selection(self)
            else:
                return visitor.visitChildren(self)




    def case_selection(self):

        localctx = IEC61131ParserParser.Case_selectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_case_selection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 473
            self.case_list()
            self.state = 474
            self.match(IEC61131ParserParser.T__1)
            self.state = 475
            self.stmt_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Case_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def case_list_elem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Case_list_elemContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Case_list_elemContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_case_list

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCase_list" ):
                return visitor.visitCase_list(self)
            else:
                return visitor.visitChildren(self)




    def case_list(self):

        localctx = IEC61131ParserParser.Case_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_case_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 477
            self.case_list_elem()
            self.state = 482
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==IEC61131ParserParser.T__11:
                self.state = 478
                self.match(IEC61131ParserParser.T__11)
                self.state = 479
                self.case_list_elem()
                self.state = 484
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Case_list_elemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_case_list_elem

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class CaseExpressionContext(Case_list_elemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Case_list_elemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseExpression" ):
                return visitor.visitCaseExpression(self)
            else:
                return visitor.visitChildren(self)


    class CaseRangeContext(Case_list_elemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Case_list_elemContext
            super().__init__(parser)
            self.start = None # Signed_intContext
            self.to = None # Signed_intContext
            self.copyFrom(ctx)

        def signed_int(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Signed_intContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Signed_intContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseRange" ):
                return visitor.visitCaseRange(self)
            else:
                return visitor.visitChildren(self)



    def case_list_elem(self):

        localctx = IEC61131ParserParser.Case_list_elemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_case_list_elem)
        try:
            self.state = 490
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                localctx = IEC61131ParserParser.CaseRangeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 485
                localctx.start = self.signed_int()
                self.state = 486
                self.match(IEC61131ParserParser.T__4)
                self.state = 487
                localctx.to = self.signed_int()
                pass

            elif la_ == 2:
                localctx = IEC61131ParserParser.CaseExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 489
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Iteration_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def for_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.For_stmtContext,0)


        def while_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.While_stmtContext,0)


        def repeat_stmt(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Repeat_stmtContext,0)


        def EXIT(self):
            return self.getToken(IEC61131ParserParser.EXIT, 0)

        def CONTINUE(self):
            return self.getToken(IEC61131ParserParser.CONTINUE, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_iteration_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIteration_stmt" ):
                return visitor.visitIteration_stmt(self)
            else:
                return visitor.visitChildren(self)




    def iteration_stmt(self):

        localctx = IEC61131ParserParser.Iteration_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_iteration_stmt)
        try:
            self.state = 497
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IEC61131ParserParser.FOR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 492
                self.for_stmt()
                pass
            elif token in [IEC61131ParserParser.WHILE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 493
                self.while_stmt()
                pass
            elif token in [IEC61131ParserParser.REPEAT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 494
                self.repeat_stmt()
                pass
            elif token in [IEC61131ParserParser.EXIT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 495
                self.match(IEC61131ParserParser.EXIT)
                pass
            elif token in [IEC61131ParserParser.CONTINUE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 496
                self.match(IEC61131ParserParser.CONTINUE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(IEC61131ParserParser.FOR, 0)

        def control_variable(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Control_variableContext,0)


        def for_list(self):
            return self.getTypedRuleContext(IEC61131ParserParser.For_listContext,0)


        def DO(self):
            return self.getToken(IEC61131ParserParser.DO, 0)

        def END_FOR(self):
            return self.getToken(IEC61131ParserParser.END_FOR, 0)

        def st_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.St_stmtContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.St_stmtContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_for_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFor_stmt" ):
                return visitor.visitFor_stmt(self)
            else:
                return visitor.visitChildren(self)




    def for_stmt(self):

        localctx = IEC61131ParserParser.For_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_for_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 499
            self.match(IEC61131ParserParser.FOR)
            self.state = 500
            self.control_variable()
            self.state = 501
            self.match(IEC61131ParserParser.T__2)
            self.state = 502
            self.for_list()
            self.state = 503
            self.match(IEC61131ParserParser.DO)
            self.state = 507
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 132)) & ~0x3f) == 0 and ((1 << (_la - 132)) & ((1 << (IEC61131ParserParser.REPEAT - 132)) | (1 << (IEC61131ParserParser.WHILE - 132)) | (1 << (IEC61131ParserParser.CASE - 132)))) != 0) or _la==IEC61131ParserParser.FOR or _la==IEC61131ParserParser.IF or _la==IEC61131ParserParser.IDENTIFIER:
                self.state = 504
                self.st_stmt()
                self.state = 509
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 510
            self.match(IEC61131ParserParser.END_FOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Control_variableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(IEC61131ParserParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_control_variable

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitControl_variable" ):
                return visitor.visitControl_variable(self)
            else:
                return visitor.visitChildren(self)




    def control_variable(self):

        localctx = IEC61131ParserParser.Control_variableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_control_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 512
            self.match(IEC61131ParserParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.ExpressionContext,i)


        def TO(self):
            return self.getToken(IEC61131ParserParser.TO, 0)

        def BY(self):
            return self.getToken(IEC61131ParserParser.BY, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_for_list

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFor_list" ):
                return visitor.visitFor_list(self)
            else:
                return visitor.visitChildren(self)




    def for_list(self):

        localctx = IEC61131ParserParser.For_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_for_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 514
            self.expression()
            self.state = 515
            self.match(IEC61131ParserParser.TO)
            self.state = 516
            self.expression()
            self.state = 519
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==IEC61131ParserParser.BY:
                self.state = 517
                self.match(IEC61131ParserParser.BY)
                self.state = 518
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class While_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.expr = None # ExpressionContext
            self.stmtblock = None # Stmt_blockContext

        def WHILE(self):
            return self.getToken(IEC61131ParserParser.WHILE, 0)

        def DO(self):
            return self.getToken(IEC61131ParserParser.DO, 0)

        def END_WHILE(self):
            return self.getToken(IEC61131ParserParser.END_WHILE, 0)

        def expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ExpressionContext,0)


        def stmt_block(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Stmt_blockContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_while_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhile_stmt" ):
                return visitor.visitWhile_stmt(self)
            else:
                return visitor.visitChildren(self)




    def while_stmt(self):

        localctx = IEC61131ParserParser.While_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_while_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 521
            self.match(IEC61131ParserParser.WHILE)
            self.state = 522
            localctx.expr = self.expression()
            self.state = 523
            self.match(IEC61131ParserParser.DO)
            self.state = 524
            localctx.stmtblock = self.stmt_block()
            self.state = 525
            self.match(IEC61131ParserParser.END_WHILE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Repeat_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPEAT(self):
            return self.getToken(IEC61131ParserParser.REPEAT, 0)

        def UNTIL(self):
            return self.getToken(IEC61131ParserParser.UNTIL, 0)

        def expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ExpressionContext,0)


        def END_REPEAT(self):
            return self.getToken(IEC61131ParserParser.END_REPEAT, 0)

        def st_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.St_stmtContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.St_stmtContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_repeat_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRepeat_stmt" ):
                return visitor.visitRepeat_stmt(self)
            else:
                return visitor.visitChildren(self)




    def repeat_stmt(self):

        localctx = IEC61131ParserParser.Repeat_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_repeat_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 527
            self.match(IEC61131ParserParser.REPEAT)
            self.state = 531
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 132)) & ~0x3f) == 0 and ((1 << (_la - 132)) & ((1 << (IEC61131ParserParser.REPEAT - 132)) | (1 << (IEC61131ParserParser.WHILE - 132)) | (1 << (IEC61131ParserParser.CASE - 132)))) != 0) or _la==IEC61131ParserParser.FOR or _la==IEC61131ParserParser.IF or _la==IEC61131ParserParser.IDENTIFIER:
                self.state = 528
                self.st_stmt()
                self.state = 533
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 534
            self.match(IEC61131ParserParser.UNTIL)
            self.state = 535
            self.expression()
            self.state = 536
            self.match(IEC61131ParserParser.END_REPEAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bool_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Bool_expressionContext,0)


        def term_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Term_expressionContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_expression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = IEC61131ParserParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_expression)
        try:
            self.state = 540
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 538
                self.bool_expression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 539
                self.term_expression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bool_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_bool_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class UnaryBoolExpressionContext(Bool_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Bool_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(IEC61131ParserParser.NOT, 0)
        def bool_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Bool_expressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryBoolExpression" ):
                return visitor.visitUnaryBoolExpression(self)
            else:
                return visitor.visitChildren(self)


    class BinaryBoolExpressionContext(Bool_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Bool_expressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def term_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Term_expressionContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Term_expressionContext,i)

        def bool_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Bool_expressionContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Bool_expressionContext,i)

        def AND(self):
            return self.getToken(IEC61131ParserParser.AND, 0)
        def OR(self):
            return self.getToken(IEC61131ParserParser.OR, 0)
        def XOR(self):
            return self.getToken(IEC61131ParserParser.XOR, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryBoolExpression" ):
                return visitor.visitBinaryBoolExpression(self)
            else:
                return visitor.visitChildren(self)


    class ParBoolExpressionContext(Bool_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Bool_expressionContext
            super().__init__(parser)
            self.subexpr = None # Bool_expressionContext
            self.copyFrom(ctx)

        def bool_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Bool_expressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParBoolExpression" ):
                return visitor.visitParBoolExpression(self)
            else:
                return visitor.visitChildren(self)


    class LeafBoolExpressionContext(Bool_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Bool_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def leaf_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Leaf_expressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeafBoolExpression" ):
                return visitor.visitLeafBoolExpression(self)
            else:
                return visitor.visitChildren(self)


    class CallBoolExpressionContext(Bool_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Bool_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def conversion_function(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Conversion_functionContext,0)

        def term_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Term_expressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallBoolExpression" ):
                return visitor.visitCallBoolExpression(self)
            else:
                return visitor.visitChildren(self)



    def bool_expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = IEC61131ParserParser.Bool_expressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 92
        self.enterRecursionRule(localctx, 92, self.RULE_bool_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 559
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                localctx = IEC61131ParserParser.BinaryBoolExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 543
                self.term_expression(0)
                self.state = 544
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << IEC61131ParserParser.T__12) | (1 << IEC61131ParserParser.T__13) | (1 << IEC61131ParserParser.T__14) | (1 << IEC61131ParserParser.T__15) | (1 << IEC61131ParserParser.T__16) | (1 << IEC61131ParserParser.T__17))) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 545
                self.term_expression(0)
                pass

            elif la_ == 2:
                localctx = IEC61131ParserParser.UnaryBoolExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 547
                self.match(IEC61131ParserParser.NOT)
                self.state = 548
                self.bool_expression(4)
                pass

            elif la_ == 3:
                localctx = IEC61131ParserParser.CallBoolExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 549
                self.conversion_function()
                self.state = 550
                self.match(IEC61131ParserParser.T__6)
                self.state = 551
                self.term_expression(0)
                self.state = 552
                self.match(IEC61131ParserParser.T__7)
                pass

            elif la_ == 4:
                localctx = IEC61131ParserParser.LeafBoolExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 554
                self.leaf_expression()
                pass

            elif la_ == 5:
                localctx = IEC61131ParserParser.ParBoolExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 555
                self.match(IEC61131ParserParser.T__6)
                self.state = 556
                localctx.subexpr = self.bool_expression(0)
                self.state = 557
                self.match(IEC61131ParserParser.T__7)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 566
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,52,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = IEC61131ParserParser.BinaryBoolExpressionContext(self, IEC61131ParserParser.Bool_expressionContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_bool_expression)
                    self.state = 561
                    if not self.precpred(self._ctx, 6):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                    self.state = 562
                    localctx.op = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(((((_la - 211)) & ~0x3f) == 0 and ((1 << (_la - 211)) & ((1 << (IEC61131ParserParser.AND - 211)) | (1 << (IEC61131ParserParser.XOR - 211)) | (1 << (IEC61131ParserParser.OR - 211)))) != 0)):
                        localctx.op = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 563
                    self.bool_expression(7) 
                self.state = 568
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,52,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Term_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_term_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class CallTermExpressionContext(Term_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Term_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def conversion_function(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Conversion_functionContext,0)

        def bool_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Bool_expressionContext,0)

        def term_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Term_expressionContext,0)

        def std_func_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Std_func_nameContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallTermExpression" ):
                return visitor.visitCallTermExpression(self)
            else:
                return visitor.visitChildren(self)


    class LeafTermExpressionContext(Term_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Term_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def leaf_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Leaf_expressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeafTermExpression" ):
                return visitor.visitLeafTermExpression(self)
            else:
                return visitor.visitChildren(self)


    class UnaryTermExpressionContext(Term_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Term_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def term_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Term_expressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryTermExpression" ):
                return visitor.visitUnaryTermExpression(self)
            else:
                return visitor.visitChildren(self)


    class BinaryTermExpressionContext(Term_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Term_expressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def term_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Term_expressionContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Term_expressionContext,i)

        def MOD(self):
            return self.getToken(IEC61131ParserParser.MOD, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryTermExpression" ):
                return visitor.visitBinaryTermExpression(self)
            else:
                return visitor.visitChildren(self)


    class ParTermExpressionContext(Term_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Term_expressionContext
            super().__init__(parser)
            self.subexpr = None # Term_expressionContext
            self.copyFrom(ctx)

        def term_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Term_expressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParTermExpression" ):
                return visitor.visitParTermExpression(self)
            else:
                return visitor.visitChildren(self)


    class CustomCallExpressionContext(Term_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IEC61131ParserParser.Term_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def custom_func_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Custom_func_nameContext,0)

        def func_param_init(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Func_param_initContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Func_param_initContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCustomCallExpression" ):
                return visitor.visitCustomCallExpression(self)
            else:
                return visitor.visitChildren(self)



    def term_expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = IEC61131ParserParser.Term_expressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 94
        self.enterRecursionRule(localctx, 94, self.RULE_term_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 606
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                localctx = IEC61131ParserParser.UnaryTermExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 570
                self.match(IEC61131ParserParser.T__21)
                self.state = 571
                self.term_expression(6)
                pass

            elif la_ == 2:
                localctx = IEC61131ParserParser.CallTermExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 572
                self.conversion_function()
                self.state = 573
                self.match(IEC61131ParserParser.T__6)
                self.state = 576
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
                if la_ == 1:
                    self.state = 574
                    self.bool_expression(0)
                    pass

                elif la_ == 2:
                    self.state = 575
                    self.term_expression(0)
                    pass


                self.state = 578
                self.match(IEC61131ParserParser.T__7)
                pass

            elif la_ == 3:
                localctx = IEC61131ParserParser.CallTermExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 580
                self.std_func_name()
                self.state = 581
                self.match(IEC61131ParserParser.T__6)
                self.state = 584
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
                if la_ == 1:
                    self.state = 582
                    self.bool_expression(0)
                    pass

                elif la_ == 2:
                    self.state = 583
                    self.term_expression(0)
                    pass


                self.state = 586
                self.match(IEC61131ParserParser.T__7)
                pass

            elif la_ == 4:
                localctx = IEC61131ParserParser.CustomCallExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 588
                self.custom_func_name()
                self.state = 589
                self.match(IEC61131ParserParser.T__6)
                self.state = 596
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==IEC61131ParserParser.IDENTIFIER:
                    self.state = 590
                    self.func_param_init()
                    self.state = 592
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==IEC61131ParserParser.T__11:
                        self.state = 591
                        self.match(IEC61131ParserParser.T__11)


                    self.state = 598
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 599
                self.match(IEC61131ParserParser.T__7)
                pass

            elif la_ == 5:
                localctx = IEC61131ParserParser.LeafTermExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 601
                self.leaf_expression()
                pass

            elif la_ == 6:
                localctx = IEC61131ParserParser.ParTermExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 602
                self.match(IEC61131ParserParser.T__6)
                self.state = 603
                localctx.subexpr = self.term_expression(0)
                self.state = 604
                self.match(IEC61131ParserParser.T__7)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 616
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,59,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 614
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
                    if la_ == 1:
                        localctx = IEC61131ParserParser.BinaryTermExpressionContext(self, IEC61131ParserParser.Term_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_term_expression)
                        self.state = 608
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 609
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==IEC61131ParserParser.T__18 or _la==IEC61131ParserParser.T__19 or _la==IEC61131ParserParser.MOD):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 610
                        self.term_expression(9)
                        pass

                    elif la_ == 2:
                        localctx = IEC61131ParserParser.BinaryTermExpressionContext(self, IEC61131ParserParser.Term_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_term_expression)
                        self.state = 611
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 612
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==IEC61131ParserParser.T__20 or _la==IEC61131ParserParser.T__21):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 613
                        self.term_expression(8)
                        pass

             
                self.state = 618
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,59,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Func_param_initContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Variable_nameContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Variable_nameContext,i)


        def constant(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ConstantContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_func_param_init

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc_param_init" ):
                return visitor.visitFunc_param_init(self)
            else:
                return visitor.visitChildren(self)




    def func_param_init(self):

        localctx = IEC61131ParserParser.Func_param_initContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_func_param_init)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 619
            self.variable_name()
            self.state = 620
            self.match(IEC61131ParserParser.T__2)
            self.state = 623
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IEC61131ParserParser.IDENTIFIER]:
                self.state = 621
                self.variable_name()
                pass
            elif token in [IEC61131ParserParser.T__20, IEC61131ParserParser.T__21, IEC61131ParserParser.TIME_MS, IEC61131ParserParser.TIME_S, IEC61131ParserParser.FALSE, IEC61131ParserParser.LREAL, IEC61131ParserParser.REAL, IEC61131ParserParser.TRUE, IEC61131ParserParser.BOOL, IEC61131ParserParser.SINT, IEC61131ParserParser.DINT, IEC61131ParserParser.INT, IEC61131ParserParser.DIGITS, IEC61131ParserParser.BINARY_INT, IEC61131ParserParser.OCTAL_INT, IEC61131ParserParser.HEX_INT]:
                self.state = 622
                self.constant()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Leaf_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_var(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Simple_varContext,0)


        def array_access(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Array_accessContext,0)


        def composite_access(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Composite_accessContext,0)


        def constant(self):
            return self.getTypedRuleContext(IEC61131ParserParser.ConstantContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_leaf_expression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeaf_expression" ):
                return visitor.visitLeaf_expression(self)
            else:
                return visitor.visitChildren(self)




    def leaf_expression(self):

        localctx = IEC61131ParserParser.Leaf_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_leaf_expression)
        try:
            self.state = 629
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 625
                self.simple_var()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 626
                self.array_access()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 627
                self.composite_access()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 628
                self.constant()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_literal(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Numeric_literalContext,0)


        def time_literal(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Time_literalContext,0)


        def bool_literal(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Bool_literalContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_constant

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstant" ):
                return visitor.visitConstant(self)
            else:
                return visitor.visitChildren(self)




    def constant(self):

        localctx = IEC61131ParserParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_constant)
        try:
            self.state = 634
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IEC61131ParserParser.T__20, IEC61131ParserParser.T__21, IEC61131ParserParser.LREAL, IEC61131ParserParser.REAL, IEC61131ParserParser.SINT, IEC61131ParserParser.DINT, IEC61131ParserParser.INT, IEC61131ParserParser.DIGITS, IEC61131ParserParser.BINARY_INT, IEC61131ParserParser.OCTAL_INT, IEC61131ParserParser.HEX_INT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 631
                self.numeric_literal()
                pass
            elif token in [IEC61131ParserParser.TIME_MS, IEC61131ParserParser.TIME_S]:
                self.enterOuterAlt(localctx, 2)
                self.state = 632
                self.time_literal()
                pass
            elif token in [IEC61131ParserParser.FALSE, IEC61131ParserParser.TRUE, IEC61131ParserParser.BOOL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 633
                self.bool_literal()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def int_literal(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Int_literalContext,0)


        def real_literal(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Real_literalContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_numeric_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_literal" ):
                return visitor.visitNumeric_literal(self)
            else:
                return visitor.visitChildren(self)




    def numeric_literal(self):

        localctx = IEC61131ParserParser.Numeric_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_numeric_literal)
        try:
            self.state = 638
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 636
                self.int_literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 637
                self.real_literal()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Int_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signed_int(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Signed_intContext,0)


        def BINARY_INT(self):
            return self.getToken(IEC61131ParserParser.BINARY_INT, 0)

        def OCTAL_INT(self):
            return self.getToken(IEC61131ParserParser.OCTAL_INT, 0)

        def HEX_INT(self):
            return self.getToken(IEC61131ParserParser.HEX_INT, 0)

        def INT(self):
            return self.getToken(IEC61131ParserParser.INT, 0)

        def SINT(self):
            return self.getToken(IEC61131ParserParser.SINT, 0)

        def DINT(self):
            return self.getToken(IEC61131ParserParser.DINT, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_int_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInt_literal" ):
                return visitor.visitInt_literal(self)
            else:
                return visitor.visitChildren(self)




    def int_literal(self):

        localctx = IEC61131ParserParser.Int_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_int_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 642
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 181)) & ~0x3f) == 0 and ((1 << (_la - 181)) & ((1 << (IEC61131ParserParser.SINT - 181)) | (1 << (IEC61131ParserParser.DINT - 181)) | (1 << (IEC61131ParserParser.INT - 181)))) != 0):
                self.state = 640
                _la = self._input.LA(1)
                if not(((((_la - 181)) & ~0x3f) == 0 and ((1 << (_la - 181)) & ((1 << (IEC61131ParserParser.SINT - 181)) | (1 << (IEC61131ParserParser.DINT - 181)) | (1 << (IEC61131ParserParser.INT - 181)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 641
                self.match(IEC61131ParserParser.T__22)


            self.state = 648
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IEC61131ParserParser.T__20, IEC61131ParserParser.T__21, IEC61131ParserParser.DIGITS]:
                self.state = 644
                self.signed_int()
                pass
            elif token in [IEC61131ParserParser.BINARY_INT]:
                self.state = 645
                self.match(IEC61131ParserParser.BINARY_INT)
                pass
            elif token in [IEC61131ParserParser.OCTAL_INT]:
                self.state = 646
                self.match(IEC61131ParserParser.OCTAL_INT)
                pass
            elif token in [IEC61131ParserParser.HEX_INT]:
                self.state = 647
                self.match(IEC61131ParserParser.HEX_INT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Uns_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGITS(self, i:int=None):
            if i is None:
                return self.getTokens(IEC61131ParserParser.DIGITS)
            else:
                return self.getToken(IEC61131ParserParser.DIGITS, i)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_uns_int

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUns_int" ):
                return visitor.visitUns_int(self)
            else:
                return visitor.visitChildren(self)




    def uns_int(self):

        localctx = IEC61131ParserParser.Uns_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_uns_int)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 650
            self.match(IEC61131ParserParser.DIGITS)
            self.state = 657
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,67,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 652
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==IEC61131ParserParser.T__23:
                        self.state = 651
                        self.match(IEC61131ParserParser.T__23)


                    self.state = 654
                    self.match(IEC61131ParserParser.DIGITS) 
                self.state = 659
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,67,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.op = None # Token

        def uns_int(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Uns_intContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_signed_int

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigned_int" ):
                return visitor.visitSigned_int(self)
            else:
                return visitor.visitChildren(self)




    def signed_int(self):

        localctx = IEC61131ParserParser.Signed_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_signed_int)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 661
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==IEC61131ParserParser.T__20 or _la==IEC61131ParserParser.T__21:
                self.state = 660
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==IEC61131ParserParser.T__20 or _la==IEC61131ParserParser.T__21):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 663
            self.uns_int()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Real_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signed_int(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Signed_intContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Signed_intContext,i)


        def uns_int(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Uns_intContext,0)


        def REAL(self):
            return self.getToken(IEC61131ParserParser.REAL, 0)

        def LREAL(self):
            return self.getToken(IEC61131ParserParser.LREAL, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_real_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReal_literal" ):
                return visitor.visitReal_literal(self)
            else:
                return visitor.visitChildren(self)




    def real_literal(self):

        localctx = IEC61131ParserParser.Real_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_real_literal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 668
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IEC61131ParserParser.REAL]:
                self.state = 665
                self.match(IEC61131ParserParser.REAL)
                pass
            elif token in [IEC61131ParserParser.LREAL]:
                self.state = 666
                self.match(IEC61131ParserParser.LREAL)
                self.state = 667
                self.match(IEC61131ParserParser.T__22)
                pass
            elif token in [IEC61131ParserParser.T__20, IEC61131ParserParser.T__21, IEC61131ParserParser.DIGITS]:
                pass
            else:
                pass
            self.state = 670
            self.signed_int()
            self.state = 671
            self.match(IEC61131ParserParser.T__10)
            self.state = 672
            self.uns_int()
            self.state = 675
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 673
                self.match(IEC61131ParserParser.T__24)
                self.state = 674
                self.signed_int()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bool_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FALSE(self):
            return self.getToken(IEC61131ParserParser.FALSE, 0)

        def TRUE(self):
            return self.getToken(IEC61131ParserParser.TRUE, 0)

        def BOOL(self):
            return self.getToken(IEC61131ParserParser.BOOL, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_bool_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBool_literal" ):
                return visitor.visitBool_literal(self)
            else:
                return visitor.visitChildren(self)




    def bool_literal(self):

        localctx = IEC61131ParserParser.Bool_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_bool_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 679
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==IEC61131ParserParser.BOOL:
                self.state = 677
                self.match(IEC61131ParserParser.BOOL)
                self.state = 678
                self.match(IEC61131ParserParser.T__22)


            self.state = 681
            _la = self._input.LA(1)
            if not(_la==IEC61131ParserParser.FALSE or _la==IEC61131ParserParser.TRUE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIME_MS(self):
            return self.getToken(IEC61131ParserParser.TIME_MS, 0)

        def TIME_S(self):
            return self.getToken(IEC61131ParserParser.TIME_S, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_time_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_literal" ):
                return visitor.visitTime_literal(self)
            else:
                return visitor.visitChildren(self)




    def time_literal(self):

        localctx = IEC61131ParserParser.Time_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_time_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 683
            _la = self._input.LA(1)
            if not(_la==IEC61131ParserParser.TIME_MS or _la==IEC61131ParserParser.TIME_S):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(IEC61131ParserParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_variable_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_name" ):
                return visitor.visitVariable_name(self)
            else:
                return visitor.visitChildren(self)




    def variable_name(self):

        localctx = IEC61131ParserParser.Variable_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_variable_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 685
            self.match(IEC61131ParserParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Custom_func_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(IEC61131ParserParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_custom_func_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCustom_func_name" ):
                return visitor.visitCustom_func_name(self)
            else:
                return visitor.visitChildren(self)




    def custom_func_name(self):

        localctx = IEC61131ParserParser.Custom_func_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_custom_func_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 687
            self.match(IEC61131ParserParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_varContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_nameContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_simple_var

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimple_var" ):
                return visitor.visitSimple_var(self)
            else:
                return visitor.visitChildren(self)




    def simple_var(self):

        localctx = IEC61131ParserParser.Simple_varContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_simple_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 689
            self.variable_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_accessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_nameContext,0)


        def term_expression(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Term_expressionContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_array_access

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArray_access" ):
                return visitor.visitArray_access(self)
            else:
                return visitor.visitChildren(self)




    def array_access(self):

        localctx = IEC61131ParserParser.Array_accessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_array_access)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 691
            self.variable_name()
            self.state = 692
            self.match(IEC61131ParserParser.T__3)
            self.state = 693
            self.term_expression(0)
            self.state = 694
            self.match(IEC61131ParserParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Composite_accessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Variable_nameContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Variable_nameContext,i)


        def array_access(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IEC61131ParserParser.Array_accessContext)
            else:
                return self.getTypedRuleContext(IEC61131ParserParser.Array_accessContext,i)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_composite_access

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComposite_access" ):
                return visitor.visitComposite_access(self)
            else:
                return visitor.visitChildren(self)




    def composite_access(self):

        localctx = IEC61131ParserParser.Composite_accessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_composite_access)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 702 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 698
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
                    if la_ == 1:
                        self.state = 696
                        self.variable_name()
                        pass

                    elif la_ == 2:
                        self.state = 697
                        self.array_access()
                        pass


                    self.state = 700
                    self.match(IEC61131ParserParser.T__10)

                else:
                    raise NoViableAltException(self)
                self.state = 704 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,73,self._ctx)

            self.state = 708
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
            if la_ == 1:
                self.state = 706
                self.variable_name()
                pass

            elif la_ == 2:
                self.state = 707
                self.array_access()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_bit_accessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_name(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Variable_nameContext,0)


        def uns_int(self):
            return self.getTypedRuleContext(IEC61131ParserParser.Uns_intContext,0)


        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_variable_bit_access

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_bit_access" ):
                return visitor.visitVariable_bit_access(self)
            else:
                return visitor.visitChildren(self)




    def variable_bit_access(self):

        localctx = IEC61131ParserParser.Variable_bit_accessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_variable_bit_access)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 710
            self.variable_name()
            self.state = 711
            self.match(IEC61131ParserParser.T__10)
            self.state = 712
            self.uns_int()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Conversion_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UINT_TO_WORD(self):
            return self.getToken(IEC61131ParserParser.UINT_TO_WORD, 0)

        def UINT_TO_BOOL(self):
            return self.getToken(IEC61131ParserParser.UINT_TO_BOOL, 0)

        def UINT_TO_USINT(self):
            return self.getToken(IEC61131ParserParser.UINT_TO_USINT, 0)

        def UINT_TO_INT(self):
            return self.getToken(IEC61131ParserParser.UINT_TO_INT, 0)

        def UINT_TO_REAL(self):
            return self.getToken(IEC61131ParserParser.UINT_TO_REAL, 0)

        def DINT_TO_UDINT(self):
            return self.getToken(IEC61131ParserParser.DINT_TO_UDINT, 0)

        def DINT_TO_UINT(self):
            return self.getToken(IEC61131ParserParser.DINT_TO_UINT, 0)

        def INT_TO_REAL(self):
            return self.getToken(IEC61131ParserParser.INT_TO_REAL, 0)

        def INT_TO_UINT(self):
            return self.getToken(IEC61131ParserParser.INT_TO_UINT, 0)

        def INT_TO_USINT(self):
            return self.getToken(IEC61131ParserParser.INT_TO_USINT, 0)

        def INT_TO_BOOL(self):
            return self.getToken(IEC61131ParserParser.INT_TO_BOOL, 0)

        def INT_TO_WORD(self):
            return self.getToken(IEC61131ParserParser.INT_TO_WORD, 0)

        def REAL_TO_INT(self):
            return self.getToken(IEC61131ParserParser.REAL_TO_INT, 0)

        def REAL_TO_UINT(self):
            return self.getToken(IEC61131ParserParser.REAL_TO_UINT, 0)

        def BOOL_TO_INT(self):
            return self.getToken(IEC61131ParserParser.BOOL_TO_INT, 0)

        def WORD_TO_UINT(self):
            return self.getToken(IEC61131ParserParser.WORD_TO_UINT, 0)

        def WORD_TO_BYTE(self):
            return self.getToken(IEC61131ParserParser.WORD_TO_BYTE, 0)

        def WORD_TO_INT(self):
            return self.getToken(IEC61131ParserParser.WORD_TO_INT, 0)

        def USINT_TO_UINT(self):
            return self.getToken(IEC61131ParserParser.USINT_TO_UINT, 0)

        def USINT_TO_BYTE(self):
            return self.getToken(IEC61131ParserParser.USINT_TO_BYTE, 0)

        def BYTE_TO_WORD(self):
            return self.getToken(IEC61131ParserParser.BYTE_TO_WORD, 0)

        def BYTE_TO_UINT(self):
            return self.getToken(IEC61131ParserParser.BYTE_TO_UINT, 0)

        def BYTE_TO_USINT(self):
            return self.getToken(IEC61131ParserParser.BYTE_TO_USINT, 0)

        def UDINT_TO_DINT(self):
            return self.getToken(IEC61131ParserParser.UDINT_TO_DINT, 0)

        def UINT_TO_DINT(self):
            return self.getToken(IEC61131ParserParser.UINT_TO_DINT, 0)

        def USINT_TO_DINT(self):
            return self.getToken(IEC61131ParserParser.USINT_TO_DINT, 0)

        def DINT_TO_USINT(self):
            return self.getToken(IEC61131ParserParser.DINT_TO_USINT, 0)

        def USINT_TO_UDINT(self):
            return self.getToken(IEC61131ParserParser.USINT_TO_UDINT, 0)

        def UDINT_TO_USINT(self):
            return self.getToken(IEC61131ParserParser.UDINT_TO_USINT, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_conversion_function

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConversion_function" ):
                return visitor.visitConversion_function(self)
            else:
                return visitor.visitChildren(self)




    def conversion_function(self):

        localctx = IEC61131ParserParser.Conversion_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_conversion_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 714
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << IEC61131ParserParser.UDINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UDINT) | (1 << IEC61131ParserParser.DINT_TO_UDINT) | (1 << IEC61131ParserParser.UDINT_TO_DINT) | (1 << IEC61131ParserParser.UINT_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_BYTE) | (1 << IEC61131ParserParser.BYTE_TO_USINT) | (1 << IEC61131ParserParser.USINT_TO_UINT) | (1 << IEC61131ParserParser.USINT_TO_DINT) | (1 << IEC61131ParserParser.DINT_TO_USINT) | (1 << IEC61131ParserParser.BYTE_TO_WORD) | (1 << IEC61131ParserParser.BYTE_TO_UINT) | (1 << IEC61131ParserParser.WORD_TO_BYTE) | (1 << IEC61131ParserParser.WORD_TO_UINT) | (1 << IEC61131ParserParser.REAL_TO_UINT) | (1 << IEC61131ParserParser.INT_TO_USINT) | (1 << IEC61131ParserParser.UINT_TO_BOOL) | (1 << IEC61131ParserParser.UINT_TO_WORD) | (1 << IEC61131ParserParser.UINT_TO_REAL) | (1 << IEC61131ParserParser.DINT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_DINT) | (1 << IEC61131ParserParser.WORD_TO_INT) | (1 << IEC61131ParserParser.REAL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_BOOL) | (1 << IEC61131ParserParser.BOOL_TO_INT) | (1 << IEC61131ParserParser.INT_TO_WORD) | (1 << IEC61131ParserParser.INT_TO_REAL) | (1 << IEC61131ParserParser.INT_TO_UINT) | (1 << IEC61131ParserParser.UINT_TO_INT))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Std_func_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUNC(self):
            return self.getToken(IEC61131ParserParser.TRUNC, 0)

        def ABS(self):
            return self.getToken(IEC61131ParserParser.ABS, 0)

        def SQRT(self):
            return self.getToken(IEC61131ParserParser.SQRT, 0)

        def LN(self):
            return self.getToken(IEC61131ParserParser.LN, 0)

        def LOG(self):
            return self.getToken(IEC61131ParserParser.LOG, 0)

        def EXP(self):
            return self.getToken(IEC61131ParserParser.EXP, 0)

        def SIN(self):
            return self.getToken(IEC61131ParserParser.SIN, 0)

        def COS(self):
            return self.getToken(IEC61131ParserParser.COS, 0)

        def TAN(self):
            return self.getToken(IEC61131ParserParser.TAN, 0)

        def ASIN(self):
            return self.getToken(IEC61131ParserParser.ASIN, 0)

        def ACOS(self):
            return self.getToken(IEC61131ParserParser.ACOS, 0)

        def ATAN(self):
            return self.getToken(IEC61131ParserParser.ATAN, 0)

        def ATAN2(self):
            return self.getToken(IEC61131ParserParser.ATAN2, 0)

        def ADD(self):
            return self.getToken(IEC61131ParserParser.ADD, 0)

        def SUB(self):
            return self.getToken(IEC61131ParserParser.SUB, 0)

        def MUL(self):
            return self.getToken(IEC61131ParserParser.MUL, 0)

        def DIV(self):
            return self.getToken(IEC61131ParserParser.DIV, 0)

        def MOD(self):
            return self.getToken(IEC61131ParserParser.MOD, 0)

        def EXPT(self):
            return self.getToken(IEC61131ParserParser.EXPT, 0)

        def MOVE(self):
            return self.getToken(IEC61131ParserParser.MOVE, 0)

        def SHL(self):
            return self.getToken(IEC61131ParserParser.SHL, 0)

        def SHR(self):
            return self.getToken(IEC61131ParserParser.SHR, 0)

        def ROL(self):
            return self.getToken(IEC61131ParserParser.ROL, 0)

        def ROR(self):
            return self.getToken(IEC61131ParserParser.ROR, 0)

        def AND(self):
            return self.getToken(IEC61131ParserParser.AND, 0)

        def OR(self):
            return self.getToken(IEC61131ParserParser.OR, 0)

        def XOR(self):
            return self.getToken(IEC61131ParserParser.XOR, 0)

        def NOT(self):
            return self.getToken(IEC61131ParserParser.NOT, 0)

        def SEL(self):
            return self.getToken(IEC61131ParserParser.SEL, 0)

        def MAX(self):
            return self.getToken(IEC61131ParserParser.MAX, 0)

        def MIN(self):
            return self.getToken(IEC61131ParserParser.MIN, 0)

        def LIMIT(self):
            return self.getToken(IEC61131ParserParser.LIMIT, 0)

        def MUX(self):
            return self.getToken(IEC61131ParserParser.MUX, 0)

        def GT(self):
            return self.getToken(IEC61131ParserParser.GT, 0)

        def GE(self):
            return self.getToken(IEC61131ParserParser.GE, 0)

        def EQ(self):
            return self.getToken(IEC61131ParserParser.EQ, 0)

        def LE(self):
            return self.getToken(IEC61131ParserParser.LE, 0)

        def LT(self):
            return self.getToken(IEC61131ParserParser.LT, 0)

        def NE(self):
            return self.getToken(IEC61131ParserParser.NE, 0)

        def LEN(self):
            return self.getToken(IEC61131ParserParser.LEN, 0)

        def LEFT(self):
            return self.getToken(IEC61131ParserParser.LEFT, 0)

        def RIGHT(self):
            return self.getToken(IEC61131ParserParser.RIGHT, 0)

        def MID(self):
            return self.getToken(IEC61131ParserParser.MID, 0)

        def CONCAT(self):
            return self.getToken(IEC61131ParserParser.CONCAT, 0)

        def INSERT(self):
            return self.getToken(IEC61131ParserParser.INSERT, 0)

        def DELETE(self):
            return self.getToken(IEC61131ParserParser.DELETE, 0)

        def REPLACE(self):
            return self.getToken(IEC61131ParserParser.REPLACE, 0)

        def FIND(self):
            return self.getToken(IEC61131ParserParser.FIND, 0)

        def getRuleIndex(self):
            return IEC61131ParserParser.RULE_std_func_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStd_func_name" ):
                return visitor.visitStd_func_name(self)
            else:
                return visitor.visitChildren(self)




    def std_func_name(self):

        localctx = IEC61131ParserParser.Std_func_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_std_func_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 716
            _la = self._input.LA(1)
            if not(((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & ((1 << (IEC61131ParserParser.REPLACE - 116)) | (1 << (IEC61131ParserParser.INSERT - 116)) | (1 << (IEC61131ParserParser.DELETE - 116)) | (1 << (IEC61131ParserParser.CONCAT - 116)) | (1 << (IEC61131ParserParser.RIGHT - 116)) | (1 << (IEC61131ParserParser.LIMIT - 116)) | (1 << (IEC61131ParserParser.TRUNC - 116)) | (1 << (IEC61131ParserParser.ATAN2 - 116)))) != 0) or ((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & ((1 << (IEC61131ParserParser.SQRT - 191)) | (1 << (IEC61131ParserParser.ASIN - 191)) | (1 << (IEC61131ParserParser.ACOS - 191)) | (1 << (IEC61131ParserParser.ATAN - 191)) | (1 << (IEC61131ParserParser.EXPT - 191)) | (1 << (IEC61131ParserParser.MOVE - 191)) | (1 << (IEC61131ParserParser.LEFT - 191)) | (1 << (IEC61131ParserParser.FIND - 191)) | (1 << (IEC61131ParserParser.NOT - 191)) | (1 << (IEC61131ParserParser.MUL - 191)) | (1 << (IEC61131ParserParser.ADD - 191)) | (1 << (IEC61131ParserParser.AND - 191)) | (1 << (IEC61131ParserParser.XOR - 191)) | (1 << (IEC61131ParserParser.SUB - 191)) | (1 << (IEC61131ParserParser.MOD - 191)) | (1 << (IEC61131ParserParser.DIV - 191)) | (1 << (IEC61131ParserParser.ABS - 191)) | (1 << (IEC61131ParserParser.LOG - 191)) | (1 << (IEC61131ParserParser.EXP - 191)) | (1 << (IEC61131ParserParser.SIN - 191)) | (1 << (IEC61131ParserParser.COS - 191)) | (1 << (IEC61131ParserParser.TAN - 191)) | (1 << (IEC61131ParserParser.SHL - 191)) | (1 << (IEC61131ParserParser.SHR - 191)) | (1 << (IEC61131ParserParser.ROL - 191)) | (1 << (IEC61131ParserParser.ROR - 191)) | (1 << (IEC61131ParserParser.SEL - 191)) | (1 << (IEC61131ParserParser.MAX - 191)) | (1 << (IEC61131ParserParser.MIN - 191)) | (1 << (IEC61131ParserParser.MUX - 191)) | (1 << (IEC61131ParserParser.LEN - 191)) | (1 << (IEC61131ParserParser.MID - 191)))) != 0) or ((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & ((1 << (IEC61131ParserParser.OR - 260)) | (1 << (IEC61131ParserParser.GT - 260)) | (1 << (IEC61131ParserParser.GE - 260)) | (1 << (IEC61131ParserParser.EQ - 260)) | (1 << (IEC61131ParserParser.LT - 260)) | (1 << (IEC61131ParserParser.LE - 260)) | (1 << (IEC61131ParserParser.NE - 260)) | (1 << (IEC61131ParserParser.LN - 260)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[19] = self.il_expr_simple_sempred
        self._predicates[46] = self.bool_expression_sempred
        self._predicates[47] = self.term_expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def il_expr_simple_sempred(self, localctx:Il_expr_simpleContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         

    def bool_expression_sempred(self, localctx:Bool_expressionContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 6)
         

    def term_expression_sempred(self, localctx:Term_expressionContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 7)
         




